"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check for existing user in localStorage first\n        const savedUsername = localStorage.getItem(\"webrtc-username\");\n        if (savedUsername) {\n            console.log(\"Found existing user in localStorage:\", savedUsername);\n            setUsername(savedUsername);\n        }\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            const handleAnswer = async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                // Valid states for setting remote answer: have-local-offer or stable (in some rollback scenarios)\n                if (pc.signalingState === \"have-local-offer\" || pc.signalingState === \"stable\") {\n                    try {\n                        await pc.setRemoteDescription(answer);\n                        setRemoteDescriptionSet(true);\n                        console.log(\"Remote description set successfully, state:\", pc.signalingState);\n                    } catch (error) {\n                        console.error(\"Failed to set remote description:\", error);\n                        return;\n                    }\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in valid state, current state:\", pc.signalingState);\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            };\n            // Remove existing answer listener and add new one to prevent duplicates\n            socketRef.current.off(\"answer\");\n            socketRef.current.on(\"answer\", handleAnswer);\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                try {\n                    await pc.setRemoteDescription(incomingCall.offer);\n                    setRemoteDescriptionSet(true);\n                    console.log(\"Remote offer set successfully in handleAcceptCall\");\n                } catch (error) {\n                    console.error(\"Failed to set remote offer in handleAcceptCall:\", error);\n                    return;\n                }\n            } else {\n                console.error(\"Cannot set remote offer: Connection not in stable state, current state:\", pc.signalingState);\n                // Try to reset the connection and try again\n                try {\n                    PeerConnection.reset();\n                    const newPc = PeerConnection.getInstance();\n                    await newPc.setRemoteDescription(incomingCall.offer);\n                    setRemoteDescriptionSet(true);\n                    console.log(\"Remote offer set successfully after connection reset\");\n                } catch (resetError) {\n                    console.error(\"Failed to set remote offer even after reset:\", resetError);\n                    return;\n                }\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 529,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 535,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 528,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlzQixVQUFVZ0IsT0FBTyxFQUFFO1lBQ3JCLDhCQUE4QjtZQUM5QmhCLFVBQVVnQixPQUFPLENBQUNtRCxJQUFJLENBQUM7WUFDdkJuRSxVQUFVZ0IsT0FBTyxDQUFDZ0MsVUFBVTtZQUM1QixnQ0FBZ0M7WUFDaENOLFdBQVc7Z0JBQ1RvRSxPQUFPSSxRQUFRLENBQUNDLE1BQU07WUFDeEIsR0FBRztRQUNMO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ0M7UUFBS0MsV0FBVTs7MEJBQ2QsOERBQUNqSiw0REFBUUE7Z0JBQ1BLLE9BQU9BO2dCQUNQNkksYUFBYS9JO2dCQUNiZ0osYUFBYWQ7Z0JBQ2JlLFlBQVlaOzs7Ozs7MEJBRWQsOERBQUN2SSw2REFBU0E7Z0JBQ1JFLFVBQVVBO2dCQUNWa0osbUJBQW1CbEQ7Z0JBQ25CbUQsV0FBV2pDO2dCQUNYOUcsbUJBQW1CQTtnQkFDbkJJLGNBQWNBO2dCQUNkNEksY0FBY3pDO2dCQUNkMEMsY0FBY3BDO2dCQUNkdkcsa0JBQWtCQTtnQkFDbEI0SSxrQkFBa0JoQztnQkFDbEIxRyxpQkFBaUJBO2dCQUNqQkksYUFBYUE7Z0JBQ2J1SSxlQUFlL0I7Z0JBQ2Z0RyxXQUFXQTtnQkFDWEUsY0FBY0E7Z0JBQ2RvSSxrQkFBa0IvQjtnQkFDbEJnQyxhQUFhaEI7Z0JBQ2JuSCxpQkFBaUJBOzs7Ozs7Ozs7Ozs7QUFJekI7R0EvaEJ3QnZCO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9wYWdlLnRzeD83NjAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IFVzZXJMaXN0IGZyb20gJ0AvY29tcG9uZW50cy9Vc2VyTGlzdCc7XG5pbXBvcnQgVmlkZW9DYWxsIGZyb20gJ0AvY29tcG9uZW50cy9WaWRlb0NhbGwnO1xuXG5pbnRlcmZhY2UgUGVlckNvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgZ2V0SW5zdGFuY2U6ICgpID0+IFJUQ1BlZXJDb25uZWN0aW9uO1xuICByZXNldDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc3QgW3VzZXJuYW1lLCBzZXRVc2VybmFtZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4oe30pO1xuICBjb25zdCBbc2hvd0VuZENhbGxCdXR0b24sIHNldFNob3dFbmRDYWxsQnV0dG9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhbGxlciwgc2V0Q2FsbGVyXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtpbmNvbWluZ0NhbGwsIHNldEluY29taW5nQ2FsbF0gPSB1c2VTdGF0ZTx7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgb2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2FsbE5vdGlmaWNhdGlvbiwgc2V0Q2FsbE5vdGlmaWNhdGlvbl0gPSB1c2VTdGF0ZTx7IG1lc3NhZ2U6IHN0cmluZzsgdHlwZTogJ3N0YXJ0JyB8ICdlbmQnIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Nob3dSZW1vdGVWaWRlbywgc2V0U2hvd1JlbW90ZVZpZGVvXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3JlbW90ZURlc2NyaXB0aW9uU2V0LCBzZXRSZW1vdGVEZXNjcmlwdGlvblNldF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdGFydENhbWVyYSwgc2V0U3RhcnRDYW1lcmFdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2FsbFRpbWVyLCBzZXRDYWxsVGltZXJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtpc0NhbGxBY3RpdmUsIHNldElzQ2FsbEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjb25uZWN0aW9uU3RhdGUsIHNldENvbm5lY3Rpb25TdGF0ZV0gPSB1c2VTdGF0ZTwnY29ubmVjdGluZycgfCAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnPignZGlzY29ubmVjdGVkJyk7XG4gIGNvbnN0IGljZUNhbmRpZGF0ZXNCdWZmZXIgPSB1c2VSZWY8UlRDSWNlQ2FuZGlkYXRlSW5pdFtdPihbXSk7XG5cbiAgY29uc3Qgc29ja2V0UmVmID0gdXNlUmVmPFNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsb2NhbFN0cmVhbVJlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBwZWVyQ29ubmVjdGlvblJlZiA9IHVzZVJlZjxSVENQZWVyQ29ubmVjdGlvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcmVtb3RlVmlkZW9FbGVtZW50LCBzZXRSZW1vdGVWaWRlb0VsZW1lbnRdID0gdXNlU3RhdGU8SFRNTFZpZGVvRWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFRpbWVyIGVmZmVjdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQ7XG4gICAgaWYgKGlzQ2FsbEFjdGl2ZSkge1xuICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHNldENhbGxUaW1lcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGludGVydmFsKSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbaXNDYWxsQWN0aXZlXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBDaGVjayBmb3IgZXhpc3RpbmcgdXNlciBpbiBsb2NhbFN0b3JhZ2UgZmlyc3RcbiAgICBjb25zdCBzYXZlZFVzZXJuYW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgIGlmIChzYXZlZFVzZXJuYW1lKSB7XG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgZXhpc3RpbmcgdXNlciBpbiBsb2NhbFN0b3JhZ2U6Jywgc2F2ZWRVc2VybmFtZSk7XG4gICAgICBzZXRVc2VybmFtZShzYXZlZFVzZXJuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIFNvY2tldC5pbyBzZXJ2ZXIgZmlyc3RcbiAgICBmZXRjaCgnaHR0cDovLzE5Mi4xNjguMTAwLjI0MjozMDAwL2FwaS9zb2NrZXQnKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnU29ja2V0LmlvIHNlcnZlciBpbml0aWFsaXplZCcpO1xuXG4gICAgICAgIC8vIENvbm5lY3QgdG8gU29ja2V0LmlvIHNlcnZlciB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gaW8oJ2h0dHA6Ly8xOTIuMTY4LjEwMC4yNDI6MzAwMCcsIHtcbiAgICAgICAgICBwYXRoOiAnL2FwaS9zb2NrZXQnLFxuICAgICAgICAgIGFkZFRyYWlsaW5nU2xhc2g6IGZhbHNlLFxuICAgICAgICAgIHRyYW5zcG9ydHM6IFsncG9sbGluZyddLCAvLyBVc2Ugb25seSBwb2xsaW5nIHRvIGF2b2lkIFdlYlNvY2tldCBpc3N1ZXNcbiAgICAgICAgICB0aW1lb3V0OiAyMDAwMCwgLy8gSW5jcmVhc2UgdGltZW91dCB0byAyMCBzZWNvbmRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gc2VydmVyIHdpdGggSUQ6Jywgc29ja2V0UmVmLmN1cnJlbnQ/LmlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Rpc2Nvbm5lY3RlZCBmcm9tIHNlcnZlcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignam9pbmVkJywgKGFsbFVzZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0FsbCB1c2VycyBqb2luZWQ6JywgYWxsVXNlcnMpO1xuICAgICAgICAgIHNldFVzZXJzKGFsbFVzZXJzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ29mZmVyJywgYXN5bmMgKHsgZnJvbSwgdG8sIG9mZmVyIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0luY29taW5nIGNhbGwgZnJvbTonLCBmcm9tKTtcbiAgICAgICAgICAvLyBTaG93IGluY29taW5nIGNhbGwgbm90aWZpY2F0aW9uIGluc3RlYWQgb2YgYXV0by1hY2NlcHRpbmdcbiAgICAgICAgICBzZXRJbmNvbWluZ0NhbGwoeyBmcm9tLCB0bywgb2ZmZXIgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZUFuc3dlciA9IGFzeW5jICh7IGZyb20sIHRvLCBhbnN3ZXIgfTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IGFuc3dlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgLy8gVmFsaWQgc3RhdGVzIGZvciBzZXR0aW5nIHJlbW90ZSBhbnN3ZXI6IGhhdmUtbG9jYWwtb2ZmZXIgb3Igc3RhYmxlIChpbiBzb21lIHJvbGxiYWNrIHNjZW5hcmlvcylcbiAgICAgICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT09IFwiaGF2ZS1sb2NhbC1vZmZlclwiIHx8IHBjLnNpZ25hbGluZ1N0YXRlID09PSBcInN0YWJsZVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgICBzZXRSZW1vdGVEZXNjcmlwdGlvblNldCh0cnVlKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBkZXNjcmlwdGlvbiBzZXQgc3VjY2Vzc2Z1bGx5LCBzdGF0ZTonLCBwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHJlbW90ZSBkZXNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHNldCByZW1vdGUgZGVzY3JpcHRpb246IENvbm5lY3Rpb24gbm90IGluIHZhbGlkIHN0YXRlLCBjdXJyZW50IHN0YXRlOicsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgICAgICB3aGlsZSAoaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbih0cnVlKTtcbiAgICAgICAgICBzZXRTaG93UmVtb3RlVmlkZW8odHJ1ZSk7XG4gICAgICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgICAgIHNldENhbGxUaW1lcigwKTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgICAgLy8gU2hvdyBjYWxsIGFjY2VwdGVkIG5vdGlmaWNhdGlvbiB0byBjYWxsZXJcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt0b30gYWNjZXB0ZWQgeW91ciBjYWxsYCxcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBhbnN3ZXIgbGlzdGVuZXIgYW5kIGFkZCBuZXcgb25lIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vZmYoJ2Fuc3dlcicpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignYW5zd2VyJywgaGFuZGxlQW5zd2VyKTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBJQ0UgY2FuZGlkYXRlOicsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgcGVlciBjb25uZWN0aW9uIGlzIHJlYWR5IGZvciBJQ0UgY2FuZGlkYXRlc1xuICAgICAgICAgIGlmIChwYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiBwYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0lDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgSUNFIGNhbmRpZGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZGVzY3JpcHRpb24gbm90IHNldCB5ZXQsIGJ1ZmZlcmluZyBJQ0UgY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBCdWZmZXIgdGhlIGNhbmRpZGF0ZSB0byBhZGQgbGF0ZXJcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZW5kLWNhbGwnLCAoeyBmcm9tLCB0byB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjYWxsLWVuZGVkJywgKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgICAgICAgZW5kQ2FsbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY2FsbC1yZWplY3RlZCcsICh7IGZyb20sIHRvIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAvLyBTaG93IGNhbGwgcmVqZWN0ZWQgbm90aWZpY2F0aW9uIHRvIGNhbGxlclxuICAgICAgICAgIGlmICh0byA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmcm9tfSByZWplY3RlZCB5b3VyIGNhbGxgLFxuICAgICAgICAgICAgICB0eXBlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcm5hbWUtdGFrZW4nLCAoeyBtZXNzYWdlIH06IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlcm5hbWUgdGFrZW46JywgbWVzc2FnZSk7XG4gICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29ja2V0LmlvIHNlcnZlcjonLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBQZWVyQ29ubmVjdGlvbjogUGVlckNvbm5lY3Rpb25NYW5hZ2VyID0gKCgpID0+IHtcbiAgICBsZXQgcGVlckNvbm5lY3Rpb246IFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBjcmVhdGVQZWVyQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZyk7XG5cbiAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciB3aGVuIGNyZWF0aW5nIG5ldyBjb25uZWN0aW9uXG4gICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcblxuICAgICAgaWYgKGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBzZW5kZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICBpZiAoIXBlZXJDb25uZWN0aW9uIS5nZXRTZW5kZXJzKCkuc29tZShzZW5kZXIgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjaykpIHtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uIS5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHJlbW90ZVZpZGVvRWxlbWVudCkge1xuICAgICAgICAgIHJlbW90ZVZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBldmVudC5zdHJlYW1zWzBdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2ljZWNhbmRpZGF0ZScsIGV2ZW50LmNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQ6JywgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBnZXRJbnN0YW5jZTogKCkgPT4ge1xuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gZm9yIGVhY2ggY2FsbFxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHBlZXJDb25uZWN0aW9uID0gY3JlYXRlUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgICAgfSxcbiAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciBvbiByZXNldFxuICAgICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGhhbmRsZVVzZXJuYW1lQ3JlYXRlZCA9IChuZXdVc2VybmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHVzZXI6JywgbmV3VXNlcm5hbWUpO1xuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3ZWJydGMtdXNlcm5hbWUnLCBuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gQWRkIGN1cnJlbnQgdXNlciB0byBsb2NhbCBsaXN0IGltbWVkaWF0ZWx5IGZvciBiZXR0ZXIgVVhcbiAgICBzZXRVc2VycyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VycyA9IHsgLi4ucHJldiwgW25ld1VzZXJuYW1lXTogbmV3VXNlcm5hbWUgfTtcbiAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCB1c2VycyB1cGRhdGVkOicsIHVwZGF0ZWRVc2Vycyk7XG4gICAgICByZXR1cm4gdXBkYXRlZFVzZXJzO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEVtaXQgdG8gc2VydmVyIHRvIHN5bmMgd2l0aCBvdGhlciBkZXZpY2VzXG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdqb2luLXVzZXInLCBuZXdVc2VybmFtZSk7XG4gICAgICBjb25zb2xlLmxvZygnRW1pdHRlZCBqb2luLXVzZXIgZXZlbnQgZm9yOicsIG5ld1VzZXJuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRNeVZpZGVvID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgIGNvbnNvbGUubG9nKHsgc3RyZWFtIH0pO1xuICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudCA9IHN0cmVhbTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIG1lZGlhIGRldmljZXM6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmRDYWxsID0gKCkgPT4ge1xuICAgIFBlZXJDb25uZWN0aW9uLnJlc2V0KCk7XG4gICAgc2V0U2hvd0VuZENhbGxCdXR0b24oZmFsc2UpO1xuICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQoZmFsc2UpO1xuICAgIHNldFN0YXJ0Q2FtZXJhKGZhbHNlKTtcbiAgICBzZXRJc0NhbGxBY3RpdmUoZmFsc2UpO1xuICAgIHNldENhbGxUaW1lcigwKTtcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudCA9IFtdO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUFjY2VwdENhbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpbmNvbWluZ0NhbGwpIHJldHVybjtcblxuICAgIC8vIFN0YXJ0IGNhbWVyYSB3aGVuIGFjY2VwdGluZyBhIGNhbGxcbiAgICBzZXRTdGFydENhbWVyYSh0cnVlKTtcblxuICAgIC8vIFdhaXQgYSBiaXQgZm9yIGNhbWVyYSB0byBzdGFydFxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKGluY29taW5nQ2FsbC5vZmZlcik7XG4gICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBvZmZlciBzZXQgc3VjY2Vzc2Z1bGx5IGluIGhhbmRsZUFjY2VwdENhbGwnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHJlbW90ZSBvZmZlciBpbiBoYW5kbGVBY2NlcHRDYWxsOicsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIG9mZmVyOiBDb25uZWN0aW9uIG5vdCBpbiBzdGFibGUgc3RhdGUsIGN1cnJlbnQgc3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAvLyBUcnkgdG8gcmVzZXQgdGhlIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2FpblxuICAgICAgICB0cnkge1xuICAgICAgICAgIFBlZXJDb25uZWN0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgY29uc3QgbmV3UGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIGF3YWl0IG5ld1BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGluY29taW5nQ2FsbC5vZmZlcik7XG4gICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBvZmZlciBzZXQgc3VjY2Vzc2Z1bGx5IGFmdGVyIGNvbm5lY3Rpb24gcmVzZXQnKTtcbiAgICAgICAgfSBjYXRjaCAocmVzZXRFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZXQgcmVtb3RlIG9mZmVyIGV2ZW4gYWZ0ZXIgcmVzZXQ6JywgcmVzZXRFcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlc1xuICAgICAgd2hpbGUgKGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50LnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQnVmZmVyZWQgSUNFIGNhbmRpZGF0ZSBhZGRlZCBzdWNjZXNzZnVsbHkgaW4gaGFuZGxlQWNjZXB0Q2FsbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZSBpbiBoYW5kbGVBY2NlcHRDYWxsOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBwYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIGF3YWl0IHBjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblxuICAgICAgLy8gQWRkIGxvY2FsIHN0cmVhbSB0byBwZWVyIGNvbm5lY3Rpb25cbiAgICAgIGlmIChsb2NhbFN0cmVhbVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgc2VuZGVyIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHRyYWNrXG4gICAgICAgICAgaWYgKCFwYy5nZXRTZW5kZXJzKCkuc29tZShzZW5kZXIgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjaykpIHtcbiAgICAgICAgICAgIHBjLmFkZFRyYWNrKHRyYWNrLCBsb2NhbFN0cmVhbVJlZi5jdXJyZW50ISk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2Fuc3dlcicsIHtcbiAgICAgICAgZnJvbTogaW5jb21pbmdDYWxsLnRvLFxuICAgICAgICB0bzogaW5jb21pbmdDYWxsLmZyb20sXG4gICAgICAgIGFuc3dlcjogcGMubG9jYWxEZXNjcmlwdGlvblxuICAgICAgfSk7XG5cbiAgICAgIHNldENhbGxlcihbaW5jb21pbmdDYWxsLmZyb20sIGluY29taW5nQ2FsbC50b10pO1xuICAgICAgc2V0SW5jb21pbmdDYWxsKG51bGwpO1xuICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICBzZXRTaG93UmVtb3RlVmlkZW8odHJ1ZSk7XG4gICAgICBzZXRJc0NhbGxBY3RpdmUodHJ1ZSk7XG4gICAgICBzZXRDYWxsVGltZXIoMCk7XG4gICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAvLyBTaG93IGNhbGwgc3RhcnQgbm90aWZpY2F0aW9uXG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogYENhbGwgc3RhcnRlZCB3aXRoICR7aW5jb21pbmdDYWxsLmZyb219YCxcbiAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhpZGUgbm90aWZpY2F0aW9uIGFmdGVyIDMgc2Vjb25kc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgICB9LCAzMDAwKTtcbiAgICB9LCAxMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVSZWplY3RDYWxsID0gKCkgPT4ge1xuICAgIGlmICghaW5jb21pbmdDYWxsKSByZXR1cm47XG5cbiAgICAvLyBOb3RpZnkgdGhlIGNhbGxlciB0aGF0IGNhbGwgd2FzIHJlamVjdGVkXG4gICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2NhbGwtcmVqZWN0ZWQnLCB7XG4gICAgICBmcm9tOiBpbmNvbWluZ0NhbGwudG8sXG4gICAgICB0bzogaW5jb21pbmdDYWxsLmZyb21cbiAgICB9KTtcblxuICAgIHNldEluY29taW5nQ2FsbChudWxsKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVFbmRDYWxsID0gKCkgPT4ge1xuICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdjYWxsLWVuZGVkJywgY2FsbGVyKTtcblxuICAgIC8vIFNob3cgY2FsbCBlbmQgbm90aWZpY2F0aW9uXG4gICAgY29uc3Qgb3RoZXJVc2VyID0gY2FsbGVyLmZpbmQodXNlciA9PiB1c2VyICE9PSB1c2VybmFtZSk7XG4gICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICBtZXNzYWdlOiBgQ2FsbCBlbmRlZCB3aXRoICR7b3RoZXJVc2VyfWAsXG4gICAgICB0eXBlOiAnZW5kJ1xuICAgIH0pO1xuXG4gICAgLy8gSGlkZSBub3RpZmljYXRpb24gYWZ0ZXIgMyBzZWNvbmRzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgIH0sIDMwMDApO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJlbW90ZVZpZGVvUmVmID0gKHJlZjogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICBzZXRSZW1vdGVWaWRlb0VsZW1lbnQocmVmKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVTdHJlYW1SZWFkeSA9IChzdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB7XG4gICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudCA9IHN0cmVhbTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVVc2VybmFtZUNoYW5nZSA9IChuZXdVc2VybmFtZTogc3RyaW5nKSA9PiB7XG4gICAgLy8gVXBkYXRlIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3ZWJydGMtdXNlcm5hbWUnLCBuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgc2V0VXNlcm5hbWUobmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIEVtaXQgdG8gc2VydmVyIHdpdGggbmV3IHVzZXJuYW1lXG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdqb2luLXVzZXInLCBuZXdVc2VybmFtZSk7XG4gICAgICBjb25zb2xlLmxvZygnVXNlcm5hbWUgY2hhbmdlZCB0bzonLCBuZXdVc2VybmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZvcm1hdFRpbWVyID0gKHNlY29uZHM6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IG1pbnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgY29uc3Qgc2VjcyA9IHNlY29uZHMgJSA2MDtcbiAgICByZXR1cm4gYCR7bWlucy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7c2Vjcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgfTtcblxuICBjb25zdCBzdGFydENhbGwgPSBhc3luYyAodXNlcjogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coeyB1c2VyIH0pO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgY3VycmVudCB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICBpZiAoIXVzZXJuYW1lIHx8IHVzZXJuYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBtYWtlIGNhbGw6IFVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGNyZWF0ZSBhIHVzZXJuYW1lIGZpcnN0JyxcbiAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldENhbGxOb3RpZmljYXRpb24obnVsbCksIDMwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHRhcmdldCB1c2VyIGV4aXN0c1xuICAgIGlmICghdXNlcnNbdXNlcl0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBtYWtlIGNhbGw6IFRhcmdldCB1c2VyIG5vdCBmb3VuZCcpO1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6IGBVc2VyICR7dXNlcn0gaXMgbm90IGF2YWlsYWJsZWAsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpLCAzMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IGNvbm5lY3Rpb24gc3RhdGUgdG8gY29ubmVjdGluZ1xuICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGluZycpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNhbWVyYSB3aGVuIG1ha2luZyBhIGNhbGxcbiAgICBzZXRTdGFydENhbWVyYSh0cnVlKTtcbiAgICBcbiAgICAvLyBXYWl0IGEgYml0IGZvciBjYW1lcmEgdG8gc3RhcnRcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgIGNvbnNvbGUubG9nKHsgb2ZmZXIgfSk7XG4gICAgICBhd2FpdCBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdvZmZlcicsIHsgZnJvbTogdXNlcm5hbWUsIHRvOiB1c2VyLCBvZmZlcjogcGMubG9jYWxEZXNjcmlwdGlvbiB9KTtcbiAgICB9LCAxMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVFZGl0VXNlciA9ICgpID0+IHtcbiAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciB0aGUgZWRpdCBtb2RhbCBpbiBWaWRlb0NhbGwgY29tcG9uZW50XG4gICAgLy8gV2UnbGwgdXNlIGEgc3RhdGUgdG8gY29tbXVuaWNhdGUgYmV0d2VlbiBjb21wb25lbnRzXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ29wZW5FZGl0TW9kYWwnKTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJVc2VyRGF0YSA9ICgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2VicnRjLXVzZXJuYW1lJyk7XG4gICAgc2V0VXNlcm5hbWUoJycpO1xuICAgIHNldFVzZXJzKHt9KTtcbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIENsZWFyIGFsbCB1c2VycyBmcm9tIHNlcnZlclxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnY2xlYXItYWxsLXVzZXJzJyk7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAvLyBSZWNvbm5lY3QgYWZ0ZXIgYSBzaG9ydCBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxtYWluIGNsYXNzTmFtZT1cImgtc2NyZWVuIGZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3dcIj5cbiAgICAgIDxVc2VyTGlzdFxuICAgICAgICB1c2Vycz17dXNlcnN9XG4gICAgICAgIGN1cnJlbnRVc2VyPXt1c2VybmFtZX1cbiAgICAgICAgb25TdGFydENhbGw9e3N0YXJ0Q2FsbH1cbiAgICAgICAgb25FZGl0VXNlcj17aGFuZGxlRWRpdFVzZXJ9XG4gICAgICAvPlxuICAgICAgPFZpZGVvQ2FsbFxuICAgICAgICB1c2VybmFtZT17dXNlcm5hbWV9XG4gICAgICAgIG9uVXNlcm5hbWVDcmVhdGVkPXtoYW5kbGVVc2VybmFtZUNyZWF0ZWR9XG4gICAgICAgIG9uRW5kQ2FsbD17aGFuZGxlRW5kQ2FsbH1cbiAgICAgICAgc2hvd0VuZENhbGxCdXR0b249e3Nob3dFbmRDYWxsQnV0dG9ufVxuICAgICAgICBpbmNvbWluZ0NhbGw9e2luY29taW5nQ2FsbH1cbiAgICAgICAgb25BY2NlcHRDYWxsPXtoYW5kbGVBY2NlcHRDYWxsfVxuICAgICAgICBvblJlamVjdENhbGw9e2hhbmRsZVJlamVjdENhbGx9XG4gICAgICAgIGNhbGxOb3RpZmljYXRpb249e2NhbGxOb3RpZmljYXRpb259XG4gICAgICAgIG9uUmVtb3RlVmlkZW9SZWY9e2hhbmRsZVJlbW90ZVZpZGVvUmVmfVxuICAgICAgICBzaG93UmVtb3RlVmlkZW89e3Nob3dSZW1vdGVWaWRlb31cbiAgICAgICAgc3RhcnRDYW1lcmE9e3N0YXJ0Q2FtZXJhfVxuICAgICAgICBvblN0cmVhbVJlYWR5PXtoYW5kbGVTdHJlYW1SZWFkeX1cbiAgICAgICAgY2FsbFRpbWVyPXtjYWxsVGltZXJ9XG4gICAgICAgIGlzQ2FsbEFjdGl2ZT17aXNDYWxsQWN0aXZlfVxuICAgICAgICBvblVzZXJuYW1lQ2hhbmdlPXtoYW5kbGVVc2VybmFtZUNoYW5nZX1cbiAgICAgICAgb25DbGVhckRhdGE9e2NsZWFyVXNlckRhdGF9XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0ZT17Y29ubmVjdGlvblN0YXRlfVxuICAgICAgLz5cbiAgICA8L21haW4+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbyIsIlVzZXJMaXN0IiwiVmlkZW9DYWxsIiwiSG9tZSIsInVzZXJuYW1lIiwic2V0VXNlcm5hbWUiLCJ1c2VycyIsInNldFVzZXJzIiwic2hvd0VuZENhbGxCdXR0b24iLCJzZXRTaG93RW5kQ2FsbEJ1dHRvbiIsImNhbGxlciIsInNldENhbGxlciIsImluY29taW5nQ2FsbCIsInNldEluY29taW5nQ2FsbCIsImNhbGxOb3RpZmljYXRpb24iLCJzZXRDYWxsTm90aWZpY2F0aW9uIiwic2hvd1JlbW90ZVZpZGVvIiwic2V0U2hvd1JlbW90ZVZpZGVvIiwicmVtb3RlRGVzY3JpcHRpb25TZXQiLCJzZXRSZW1vdGVEZXNjcmlwdGlvblNldCIsInN0YXJ0Q2FtZXJhIiwic2V0U3RhcnRDYW1lcmEiLCJjYWxsVGltZXIiLCJzZXRDYWxsVGltZXIiLCJpc0NhbGxBY3RpdmUiLCJzZXRJc0NhbGxBY3RpdmUiLCJjb25uZWN0aW9uU3RhdGUiLCJzZXRDb25uZWN0aW9uU3RhdGUiLCJpY2VDYW5kaWRhdGVzQnVmZmVyIiwic29ja2V0UmVmIiwibG9jYWxTdHJlYW1SZWYiLCJwZWVyQ29ubmVjdGlvblJlZiIsInJlbW90ZVZpZGVvRWxlbWVudCIsInNldFJlbW90ZVZpZGVvRWxlbWVudCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJwcmV2IiwiY2xlYXJJbnRlcnZhbCIsInNhdmVkVXNlcm5hbWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uc29sZSIsImxvZyIsImZldGNoIiwidGhlbiIsImN1cnJlbnQiLCJwYXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0Iiwib24iLCJpZCIsImVycm9yIiwiYWxsVXNlcnMiLCJmcm9tIiwidG8iLCJvZmZlciIsImhhbmRsZUFuc3dlciIsImFuc3dlciIsInBjIiwiUGVlckNvbm5lY3Rpb24iLCJnZXRJbnN0YW5jZSIsInNpZ25hbGluZ1N0YXRlIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJsZW5ndGgiLCJjYW5kaWRhdGUiLCJzaGlmdCIsImFkZEljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsIm1lc3NhZ2UiLCJ0eXBlIiwic2V0VGltZW91dCIsIm9mZiIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsImVuZENhbGwiLCJjYXRjaCIsImRpc2Nvbm5lY3QiLCJwZWVyQ29ubmVjdGlvbiIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwiY29uZmlnIiwiaWNlU2VydmVycyIsInVybHMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImdldFNlbmRlcnMiLCJzb21lIiwic2VuZGVyIiwiYWRkVHJhY2siLCJvbnRyYWNrIiwiZXZlbnQiLCJzcmNPYmplY3QiLCJzdHJlYW1zIiwib25pY2VjYW5kaWRhdGUiLCJlbWl0Iiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJjbG9zZSIsInJlc2V0IiwiaGFuZGxlVXNlcm5hbWVDcmVhdGVkIiwibmV3VXNlcm5hbWUiLCJzZXRJdGVtIiwidXBkYXRlZFVzZXJzIiwic3RhcnRNeVZpZGVvIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ2aWRlbyIsImhhbmRsZUFjY2VwdENhbGwiLCJuZXdQYyIsInJlc2V0RXJyb3IiLCJjcmVhdGVBbnN3ZXIiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImhhbmRsZVJlamVjdENhbGwiLCJoYW5kbGVFbmRDYWxsIiwib3RoZXJVc2VyIiwiZmluZCIsInVzZXIiLCJoYW5kbGVSZW1vdGVWaWRlb1JlZiIsInJlZiIsImhhbmRsZVN0cmVhbVJlYWR5IiwiaGFuZGxlVXNlcm5hbWVDaGFuZ2UiLCJmb3JtYXRUaW1lciIsInNlY29uZHMiLCJtaW5zIiwiTWF0aCIsImZsb29yIiwic2VjcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydENhbGwiLCJ0cmltIiwiY3JlYXRlT2ZmZXIiLCJoYW5kbGVFZGl0VXNlciIsIkN1c3RvbUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsImNsZWFyVXNlckRhdGEiLCJyZW1vdmVJdGVtIiwibG9jYXRpb24iLCJyZWxvYWQiLCJtYWluIiwiY2xhc3NOYW1lIiwiY3VycmVudFVzZXIiLCJvblN0YXJ0Q2FsbCIsIm9uRWRpdFVzZXIiLCJvblVzZXJuYW1lQ3JlYXRlZCIsIm9uRW5kQ2FsbCIsIm9uQWNjZXB0Q2FsbCIsIm9uUmVqZWN0Q2FsbCIsIm9uUmVtb3RlVmlkZW9SZWYiLCJvblN0cmVhbVJlYWR5Iiwib25Vc2VybmFtZUNoYW5nZSIsIm9uQ2xlYXJEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});