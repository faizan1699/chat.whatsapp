"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Clear any old data and start fresh\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            const handleAnswer = async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                if (pc.signalingState === \"have-local-offer\") {\n                    await pc.setRemoteDescription(answer);\n                    setRemoteDescriptionSet(true);\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in have-local-offer state, current state:\", pc.signalingState);\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            };\n            // Remove existing answer listener and add new one to prevent duplicates\n            socketRef.current.off(\"answer\");\n            socketRef.current.on(\"answer\", handleAnswer);\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                await pc.setRemoteDescription(incomingCall.offer);\n                setRemoteDescriptionSet(true);\n            } else {\n                console.error(\"Cannot set remote description: Connection not in stable state, current state:\", pc.signalingState);\n                return;\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 504,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 510,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 503,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTs7Ozs7Ozs7Ozs7O0FBSXpCO0dBdGdCd0J2QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBVc2VyTGlzdCBmcm9tICdAL2NvbXBvbmVudHMvVXNlckxpc3QnO1xuaW1wb3J0IFZpZGVvQ2FsbCBmcm9tICdAL2NvbXBvbmVudHMvVmlkZW9DYWxsJztcblxuaW50ZXJmYWNlIFBlZXJDb25uZWN0aW9uTWFuYWdlciB7XG4gIGdldEluc3RhbmNlOiAoKSA9PiBSVENQZWVyQ29ubmVjdGlvbjtcbiAgcmVzZXQ6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFt1c2VybmFtZSwgc2V0VXNlcm5hbWVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+KHt9KTtcbiAgY29uc3QgW3Nob3dFbmRDYWxsQnV0dG9uLCBzZXRTaG93RW5kQ2FsbEJ1dHRvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYWxsZXIsIHNldENhbGxlcl0gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbaW5jb21pbmdDYWxsLCBzZXRJbmNvbWluZ0NhbGxdID0gdXNlU3RhdGU8eyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NhbGxOb3RpZmljYXRpb24sIHNldENhbGxOb3RpZmljYXRpb25dID0gdXNlU3RhdGU8eyBtZXNzYWdlOiBzdHJpbmc7IHR5cGU6ICdzdGFydCcgfCAnZW5kJyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93UmVtb3RlVmlkZW8sIHNldFNob3dSZW1vdGVWaWRlb10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZW1vdGVEZXNjcmlwdGlvblNldCwgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhcnRDYW1lcmEsIHNldFN0YXJ0Q2FtZXJhXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhbGxUaW1lciwgc2V0Q2FsbFRpbWVyXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbaXNDYWxsQWN0aXZlLCBzZXRJc0NhbGxBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8J2Nvbm5lY3RpbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJz4oJ2Rpc2Nvbm5lY3RlZCcpO1xuICBjb25zdCBpY2VDYW5kaWRhdGVzQnVmZmVyID0gdXNlUmVmPFJUQ0ljZUNhbmRpZGF0ZUluaXRbXT4oW10pO1xuXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9jYWxTdHJlYW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgcGVlckNvbm5lY3Rpb25SZWYgPSB1c2VSZWY8UlRDUGVlckNvbm5lY3Rpb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3JlbW90ZVZpZGVvRWxlbWVudCwgc2V0UmVtb3RlVmlkZW9FbGVtZW50XSA9IHVzZVN0YXRlPEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICAvLyBUaW1lciBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0O1xuICAgIGlmIChpc0NhbGxBY3RpdmUpIHtcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsVGltZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpbnRlcnZhbCkgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgfTtcbiAgfSwgW2lzQ2FsbEFjdGl2ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgYW55IG9sZCBkYXRhIGFuZCBzdGFydCBmcmVzaFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3ZWJydGMtdXNlcm5hbWUnKTtcbiAgICBzZXRVc2VybmFtZSgnJyk7XG4gICAgc2V0VXNlcnMoe30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBTb2NrZXQuaW8gc2VydmVyIGZpcnN0XG4gICAgZmV0Y2goJ2h0dHA6Ly8xOTIuMTY4LjEwMC4yNDI6MzAwMC9hcGkvc29ja2V0JylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NvY2tldC5pbyBzZXJ2ZXIgaW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAvLyBDb25uZWN0IHRvIFNvY2tldC5pbyBzZXJ2ZXIgd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKCdodHRwOi8vMTkyLjE2OC4xMDAuMjQyOjMwMDAnLCB7XG4gICAgICAgICAgcGF0aDogJy9hcGkvc29ja2V0JyxcbiAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoOiBmYWxzZSxcbiAgICAgICAgICB0cmFuc3BvcnRzOiBbJ3BvbGxpbmcnXSwgLy8gVXNlIG9ubHkgcG9sbGluZyB0byBhdm9pZCBXZWJTb2NrZXQgaXNzdWVzXG4gICAgICAgICAgdGltZW91dDogMjAwMDAsIC8vIEluY3JlYXNlIHRpbWVvdXQgdG8gMjAgc2Vjb25kc1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHNlcnZlciB3aXRoIElEOicsIHNvY2tldFJlZi5jdXJyZW50Py5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2pvaW5lZCcsIChhbGxVc2VyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgdXNlcnMgam9pbmVkOicsIGFsbFVzZXJzKTtcbiAgICAgICAgICBzZXRVc2VycyhhbGxVc2Vycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdvZmZlcicsIGFzeW5jICh7IGZyb20sIHRvLCBvZmZlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgb2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbmNvbWluZyBjYWxsIGZyb206JywgZnJvbSk7XG4gICAgICAgICAgLy8gU2hvdyBpbmNvbWluZyBjYWxsIG5vdGlmaWNhdGlvbiBpbnN0ZWFkIG9mIGF1dG8tYWNjZXB0aW5nXG4gICAgICAgICAgc2V0SW5jb21pbmdDYWxsKHsgZnJvbSwgdG8sIG9mZmVyIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBoYW5kbGVBbnN3ZXIgPSBhc3luYyAoeyBmcm9tLCB0bywgYW5zd2VyIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBhbnN3ZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gXCJoYXZlLWxvY2FsLW9mZmVyXCIpIHtcbiAgICAgICAgICAgIGF3YWl0IHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICBzZXRSZW1vdGVEZXNjcmlwdGlvblNldCh0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHNldCByZW1vdGUgZGVzY3JpcHRpb246IENvbm5lY3Rpb24gbm90IGluIGhhdmUtbG9jYWwtb2ZmZXIgc3RhdGUsIGN1cnJlbnQgc3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlc1xuICAgICAgICAgIHdoaWxlIChpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQnVmZmVyZWQgSUNFIGNhbmRpZGF0ZSBhZGRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGU6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgICAgIHNldFNob3dSZW1vdGVWaWRlbyh0cnVlKTtcbiAgICAgICAgICBzZXRJc0NhbGxBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG5cbiAgICAgICAgICAvLyBTaG93IGNhbGwgYWNjZXB0ZWQgbm90aWZpY2F0aW9uIHRvIGNhbGxlclxuICAgICAgICAgIGlmIChmcm9tID09PSB1c2VybmFtZSkge1xuICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3RvfSBhY2NlcHRlZCB5b3VyIGNhbGxgLFxuICAgICAgICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGFuc3dlciBsaXN0ZW5lciBhbmQgYWRkIG5ldyBvbmUgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9mZignYW5zd2VyJyk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdhbnN3ZXInLCBoYW5kbGVBbnN3ZXIpO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdpY2VjYW5kaWRhdGUnLCBhc3luYyAoY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIElDRSBjYW5kaWRhdGU6JywgY2FuZGlkYXRlKTtcbiAgICAgICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBwZWVyIGNvbm5lY3Rpb24gaXMgcmVhZHkgZm9yIElDRSBjYW5kaWRhdGVzXG4gICAgICAgICAgaWYgKHBjLnJlbW90ZURlc2NyaXB0aW9uICYmIHBjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSUNFIGNhbmRpZGF0ZSBhZGRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBJQ0UgY2FuZGlkYXRlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBkZXNjcmlwdGlvbiBub3Qgc2V0IHlldCwgYnVmZmVyaW5nIElDRSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgIC8vIEJ1ZmZlciB0aGUgY2FuZGlkYXRlIHRvIGFkZCBsYXRlclxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50LnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdlbmQtY2FsbCcsICh7IGZyb20sIHRvIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbih0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2NhbGwtZW5kZWQnLCAoKSA9PiB7XG4gICAgICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKGZhbHNlKTtcbiAgICAgICAgICBlbmRDYWxsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjYWxsLXJlamVjdGVkJywgKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIC8vIFNob3cgY2FsbCByZWplY3RlZCBub3RpZmljYXRpb24gdG8gY2FsbGVyXG4gICAgICAgICAgaWYgKHRvID09PSB1c2VybmFtZSkge1xuICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2Zyb219IHJlamVjdGVkIHlvdXIgY2FsbGAsXG4gICAgICAgICAgICAgIHR5cGU6ICdlbmQnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VybmFtZS10YWtlbicsICh7IG1lc3NhZ2UgfTogeyBtZXNzYWdlOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VybmFtZSB0YWtlbjonLCBtZXNzYWdlKTtcbiAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiAnZW5kJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTb2NrZXQuaW8gc2VydmVyOicsIGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IFBlZXJDb25uZWN0aW9uOiBQZWVyQ29ubmVjdGlvbk1hbmFnZXIgPSAoKCkgPT4ge1xuICAgIGxldCBwZWVyQ29ubmVjdGlvbjogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0IGNyZWF0ZVBlZXJDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBpY2VTZXJ2ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsczogJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgcGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29uZmlnKTtcblxuICAgICAgLy8gQ2xlYXIgSUNFIGNhbmRpZGF0ZXMgYnVmZmVyIHdoZW4gY3JlYXRpbmcgbmV3IGNvbm5lY3Rpb25cbiAgICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudCA9IFtdO1xuXG4gICAgICBpZiAobG9jYWxTdHJlYW1SZWYuY3VycmVudCkge1xuICAgICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbmRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIGlmICghcGVlckNvbm5lY3Rpb24hLmdldFNlbmRlcnMoKS5zb21lKHNlbmRlciA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKSkge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24hLmFkZFRyYWNrKHRyYWNrLCBsb2NhbFN0cmVhbVJlZi5jdXJyZW50ISk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGVlckNvbm5lY3Rpb24ub250cmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAocmVtb3RlVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgcmVtb3RlVmlkZW9FbGVtZW50LnNyY09iamVjdCA9IGV2ZW50LnN0cmVhbXNbMF07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnaWNlY2FuZGlkYXRlJywgZXZlbnQuY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcGVlckNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZDonLCBwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldEluc3RhbmNlOiAoKSA9PiB7XG4gICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiBmb3IgZWFjaCBjYWxsXG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGVlckNvbm5lY3Rpb24gPSBjcmVhdGVQZWVyQ29ubmVjdGlvbigpO1xuICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb247XG4gICAgICB9LFxuICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgSUNFIGNhbmRpZGF0ZXMgYnVmZmVyIG9uIHJlc2V0XG4gICAgICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudCA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgY29uc3QgaGFuZGxlVXNlcm5hbWVDcmVhdGVkID0gKG5ld1VzZXJuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgdXNlcjonLCBuZXdVc2VybmFtZSk7XG4gICAgc2V0VXNlcm5hbWUobmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScsIG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBBZGQgY3VycmVudCB1c2VyIHRvIGxvY2FsIGxpc3QgaW1tZWRpYXRlbHkgZm9yIGJldHRlciBVWFxuICAgIHNldFVzZXJzKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZFVzZXJzID0geyAuLi5wcmV2LCBbbmV3VXNlcm5hbWVdOiBuZXdVc2VybmFtZSB9O1xuICAgICAgY29uc29sZS5sb2coJ0xvY2FsIHVzZXJzIHVwZGF0ZWQ6JywgdXBkYXRlZFVzZXJzKTtcbiAgICAgIHJldHVybiB1cGRhdGVkVXNlcnM7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRW1pdCB0byBzZXJ2ZXIgdG8gc3luYyB3aXRoIG90aGVyIGRldmljZXNcbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2pvaW4tdXNlcicsIG5ld1VzZXJuYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFbWl0dGVkIGpvaW4tdXNlciBldmVudCBmb3I6JywgbmV3VXNlcm5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzdGFydE15VmlkZW8gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUsIHZpZGVvOiB0cnVlIH0pO1xuICAgICAgY29uc29sZS5sb2coeyBzdHJlYW0gfSk7XG4gICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50ID0gc3RyZWFtO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3NpbmcgbWVkaWEgZGV2aWNlczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGVuZENhbGwgPSAoKSA9PiB7XG4gICAgUGVlckNvbm5lY3Rpb24ucmVzZXQoKTtcbiAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbihmYWxzZSk7XG4gICAgc2V0U2hvd1JlbW90ZVZpZGVvKGZhbHNlKTtcbiAgICBzZXRSZW1vdGVEZXNjcmlwdGlvblNldChmYWxzZSk7XG4gICAgc2V0U3RhcnRDYW1lcmEoZmFsc2UpO1xuICAgIHNldElzQ2FsbEFjdGl2ZShmYWxzZSk7XG4gICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50ID0gW107XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQWNjZXB0Q2FsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWluY29taW5nQ2FsbCkgcmV0dXJuO1xuXG4gICAgLy8gU3RhcnQgY2FtZXJhIHdoZW4gYWNjZXB0aW5nIGEgY2FsbFxuICAgIHNldFN0YXJ0Q2FtZXJhKHRydWUpO1xuXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FtZXJhIHRvIHN0YXJ0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICAgIGF3YWl0IHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKGluY29taW5nQ2FsbC5vZmZlcik7XG4gICAgICAgIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0KHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHNldCByZW1vdGUgZGVzY3JpcHRpb246IENvbm5lY3Rpb24gbm90IGluIHN0YWJsZSBzdGF0ZSwgY3VycmVudCBzdGF0ZTonLCBwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGVzXG4gICAgICB3aGlsZSAoaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCdWZmZXJlZCBJQ0UgY2FuZGlkYXRlIGFkZGVkIHN1Y2Nlc3NmdWxseSBpbiBoYW5kbGVBY2NlcHRDYWxsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlIGluIGhhbmRsZUFjY2VwdENhbGw6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXG4gICAgICAvLyBBZGQgbG9jYWwgc3RyZWFtIHRvIHBlZXIgY29ubmVjdGlvblxuICAgICAgaWYgKGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBzZW5kZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICBpZiAoIXBjLmdldFNlbmRlcnMoKS5zb21lKHNlbmRlciA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKSkge1xuICAgICAgICAgICAgcGMuYWRkVHJhY2sodHJhY2ssIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnYW5zd2VyJywge1xuICAgICAgICBmcm9tOiBpbmNvbWluZ0NhbGwudG8sXG4gICAgICAgIHRvOiBpbmNvbWluZ0NhbGwuZnJvbSxcbiAgICAgICAgYW5zd2VyOiBwYy5sb2NhbERlc2NyaXB0aW9uXG4gICAgICB9KTtcblxuICAgICAgc2V0Q2FsbGVyKFtpbmNvbWluZ0NhbGwuZnJvbSwgaW5jb21pbmdDYWxsLnRvXSk7XG4gICAgICBzZXRJbmNvbWluZ0NhbGwobnVsbCk7XG4gICAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbih0cnVlKTtcbiAgICAgIHNldFNob3dSZW1vdGVWaWRlbyh0cnVlKTtcbiAgICAgIHNldElzQ2FsbEFjdGl2ZSh0cnVlKTtcbiAgICAgIHNldENhbGxUaW1lcigwKTtcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG5cbiAgICAgIC8vIFNob3cgY2FsbCBzdGFydCBub3RpZmljYXRpb25cbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiBgQ2FsbCBzdGFydGVkIHdpdGggJHtpbmNvbWluZ0NhbGwuZnJvbX1gLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgLy8gSGlkZSBub3RpZmljYXRpb24gYWZ0ZXIgMyBzZWNvbmRzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgIH0sIDMwMDApO1xuICAgIH0sIDEwMDApO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJlamVjdENhbGwgPSAoKSA9PiB7XG4gICAgaWYgKCFpbmNvbWluZ0NhbGwpIHJldHVybjtcblxuICAgIC8vIE5vdGlmeSB0aGUgY2FsbGVyIHRoYXQgY2FsbCB3YXMgcmVqZWN0ZWRcbiAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnY2FsbC1yZWplY3RlZCcsIHtcbiAgICAgIGZyb206IGluY29taW5nQ2FsbC50byxcbiAgICAgIHRvOiBpbmNvbWluZ0NhbGwuZnJvbVxuICAgIH0pO1xuXG4gICAgc2V0SW5jb21pbmdDYWxsKG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUVuZENhbGwgPSAoKSA9PiB7XG4gICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2NhbGwtZW5kZWQnLCBjYWxsZXIpO1xuXG4gICAgLy8gU2hvdyBjYWxsIGVuZCBub3RpZmljYXRpb25cbiAgICBjb25zdCBvdGhlclVzZXIgPSBjYWxsZXIuZmluZCh1c2VyID0+IHVzZXIgIT09IHVzZXJuYW1lKTtcbiAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgIG1lc3NhZ2U6IGBDYWxsIGVuZGVkIHdpdGggJHtvdGhlclVzZXJ9YCxcbiAgICAgIHR5cGU6ICdlbmQnXG4gICAgfSk7XG5cbiAgICAvLyBIaWRlIG5vdGlmaWNhdGlvbiBhZnRlciAzIHNlY29uZHNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgfSwgMzAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVtb3RlVmlkZW9SZWYgPSAocmVmOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIHNldFJlbW90ZVZpZGVvRWxlbWVudChyZWYpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVN0cmVhbVJlYWR5ID0gKHN0cmVhbTogTWVkaWFTdHJlYW0pID0+IHtcbiAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50ID0gc3RyZWFtO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVVzZXJuYW1lQ2hhbmdlID0gKG5ld1VzZXJuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAvLyBVcGRhdGUgbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScsIG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICBzZXRVc2VybmFtZShuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gRW1pdCB0byBzZXJ2ZXIgd2l0aCBuZXcgdXNlcm5hbWVcbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2pvaW4tdXNlcicsIG5ld1VzZXJuYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VybmFtZSBjaGFuZ2VkIHRvOicsIG5ld1VzZXJuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0VGltZXIgPSAoc2Vjb25kczogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgbWlucyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBjb25zdCBzZWNzID0gc2Vjb25kcyAlIDYwO1xuICAgIHJldHVybiBgJHttaW5zLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtzZWNzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICB9O1xuXG4gIGNvbnN0IHN0YXJ0Q2FsbCA9IGFzeW5jICh1c2VyOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZyh7IHVzZXIgfSk7XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCBjdXJyZW50IHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgIGlmICghdXNlcm5hbWUgfHwgdXNlcm5hbWUudHJpbSgpID09PSAnJykge1xuICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IG1ha2UgY2FsbDogVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgY3JlYXRlIGEgdXNlcm5hbWUgZmlyc3QnLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKSwgMzAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgdGFyZ2V0IHVzZXIgZXhpc3RzXG4gICAgaWYgKCF1c2Vyc1t1c2VyXSkge1xuICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IG1ha2UgY2FsbDogVGFyZ2V0IHVzZXIgbm90IGZvdW5kJyk7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogYFVzZXIgJHt1c2VyfSBpcyBub3QgYXZhaWxhYmxlYCxcbiAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldENhbGxOb3RpZmljYXRpb24obnVsbCksIDMwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgY29ubmVjdGlvbiBzdGF0ZSB0byBjb25uZWN0aW5nXG4gICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgXG4gICAgLy8gU3RhcnQgY2FtZXJhIHdoZW4gbWFraW5nIGEgY2FsbFxuICAgIHNldFN0YXJ0Q2FtZXJhKHRydWUpO1xuICAgIFxuICAgIC8vIFdhaXQgYSBiaXQgZm9yIGNhbWVyYSB0byBzdGFydFxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgY29uc29sZS5sb2coeyBvZmZlciB9KTtcbiAgICAgIGF3YWl0IHBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ29mZmVyJywgeyBmcm9tOiB1c2VybmFtZSwgdG86IHVzZXIsIG9mZmVyOiBwYy5sb2NhbERlc2NyaXB0aW9uIH0pO1xuICAgIH0sIDEwMDApO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUVkaXRVc2VyID0gKCkgPT4ge1xuICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIHRoZSBlZGl0IG1vZGFsIGluIFZpZGVvQ2FsbCBjb21wb25lbnRcbiAgICAvLyBXZSdsbCB1c2UgYSBzdGF0ZSB0byBjb21tdW5pY2F0ZSBiZXR3ZWVuIGNvbXBvbmVudHNcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnb3BlbkVkaXRNb2RhbCcpO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfTtcblxuICBjb25zdCBjbGVhclVzZXJEYXRhID0gKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3ZWJydGMtdXNlcm5hbWUnKTtcbiAgICBzZXRVc2VybmFtZSgnJyk7XG4gICAgc2V0VXNlcnMoe30pO1xuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ2xlYXIgYWxsIHVzZXJzIGZyb20gc2VydmVyXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdjbGVhci1hbGwtdXNlcnMnKTtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIC8vIFJlY29ubmVjdCBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwiaC1zY3JlZW4gZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvd1wiPlxuICAgICAgPFVzZXJMaXN0XG4gICAgICAgIHVzZXJzPXt1c2Vyc31cbiAgICAgICAgY3VycmVudFVzZXI9e3VzZXJuYW1lfVxuICAgICAgICBvblN0YXJ0Q2FsbD17c3RhcnRDYWxsfVxuICAgICAgICBvbkVkaXRVc2VyPXtoYW5kbGVFZGl0VXNlcn1cbiAgICAgIC8+XG4gICAgICA8VmlkZW9DYWxsXG4gICAgICAgIHVzZXJuYW1lPXt1c2VybmFtZX1cbiAgICAgICAgb25Vc2VybmFtZUNyZWF0ZWQ9e2hhbmRsZVVzZXJuYW1lQ3JlYXRlZH1cbiAgICAgICAgb25FbmRDYWxsPXtoYW5kbGVFbmRDYWxsfVxuICAgICAgICBzaG93RW5kQ2FsbEJ1dHRvbj17c2hvd0VuZENhbGxCdXR0b259XG4gICAgICAgIGluY29taW5nQ2FsbD17aW5jb21pbmdDYWxsfVxuICAgICAgICBvbkFjY2VwdENhbGw9e2hhbmRsZUFjY2VwdENhbGx9XG4gICAgICAgIG9uUmVqZWN0Q2FsbD17aGFuZGxlUmVqZWN0Q2FsbH1cbiAgICAgICAgY2FsbE5vdGlmaWNhdGlvbj17Y2FsbE5vdGlmaWNhdGlvbn1cbiAgICAgICAgb25SZW1vdGVWaWRlb1JlZj17aGFuZGxlUmVtb3RlVmlkZW9SZWZ9XG4gICAgICAgIHNob3dSZW1vdGVWaWRlbz17c2hvd1JlbW90ZVZpZGVvfVxuICAgICAgICBzdGFydENhbWVyYT17c3RhcnRDYW1lcmF9XG4gICAgICAgIG9uU3RyZWFtUmVhZHk9e2hhbmRsZVN0cmVhbVJlYWR5fVxuICAgICAgICBjYWxsVGltZXI9e2NhbGxUaW1lcn1cbiAgICAgICAgaXNDYWxsQWN0aXZlPXtpc0NhbGxBY3RpdmV9XG4gICAgICAgIG9uVXNlcm5hbWVDaGFuZ2U9e2hhbmRsZVVzZXJuYW1lQ2hhbmdlfVxuICAgICAgICBvbkNsZWFyRGF0YT17Y2xlYXJVc2VyRGF0YX1cbiAgICAgICAgY29ubmVjdGlvblN0YXRlPXtjb25uZWN0aW9uU3RhdGV9XG4gICAgICAvPlxuICAgIDwvbWFpbj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImlvIiwiVXNlckxpc3QiLCJWaWRlb0NhbGwiLCJIb21lIiwidXNlcm5hbWUiLCJzZXRVc2VybmFtZSIsInVzZXJzIiwic2V0VXNlcnMiLCJzaG93RW5kQ2FsbEJ1dHRvbiIsInNldFNob3dFbmRDYWxsQnV0dG9uIiwiY2FsbGVyIiwic2V0Q2FsbGVyIiwiaW5jb21pbmdDYWxsIiwic2V0SW5jb21pbmdDYWxsIiwiY2FsbE5vdGlmaWNhdGlvbiIsInNldENhbGxOb3RpZmljYXRpb24iLCJzaG93UmVtb3RlVmlkZW8iLCJzZXRTaG93UmVtb3RlVmlkZW8iLCJyZW1vdGVEZXNjcmlwdGlvblNldCIsInNldFJlbW90ZURlc2NyaXB0aW9uU2V0Iiwic3RhcnRDYW1lcmEiLCJzZXRTdGFydENhbWVyYSIsImNhbGxUaW1lciIsInNldENhbGxUaW1lciIsImlzQ2FsbEFjdGl2ZSIsInNldElzQ2FsbEFjdGl2ZSIsImNvbm5lY3Rpb25TdGF0ZSIsInNldENvbm5lY3Rpb25TdGF0ZSIsImljZUNhbmRpZGF0ZXNCdWZmZXIiLCJzb2NrZXRSZWYiLCJsb2NhbFN0cmVhbVJlZiIsInBlZXJDb25uZWN0aW9uUmVmIiwicmVtb3RlVmlkZW9FbGVtZW50Iiwic2V0UmVtb3RlVmlkZW9FbGVtZW50IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJjbGVhckludGVydmFsIiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsImZldGNoIiwidGhlbiIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50IiwicGF0aCIsImFkZFRyYWlsaW5nU2xhc2giLCJ0cmFuc3BvcnRzIiwidGltZW91dCIsIm9uIiwiaWQiLCJlcnJvciIsImFsbFVzZXJzIiwiZnJvbSIsInRvIiwib2ZmZXIiLCJoYW5kbGVBbnN3ZXIiLCJhbnN3ZXIiLCJwYyIsIlBlZXJDb25uZWN0aW9uIiwiZ2V0SW5zdGFuY2UiLCJzaWduYWxpbmdTdGF0ZSIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwibGVuZ3RoIiwiY2FuZGlkYXRlIiwic2hpZnQiLCJhZGRJY2VDYW5kaWRhdGUiLCJSVENJY2VDYW5kaWRhdGUiLCJtZXNzYWdlIiwidHlwZSIsInNldFRpbWVvdXQiLCJvZmYiLCJyZW1vdGVEZXNjcmlwdGlvbiIsInB1c2giLCJlbmRDYWxsIiwiY2F0Y2giLCJkaXNjb25uZWN0IiwicGVlckNvbm5lY3Rpb24iLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsImNvbmZpZyIsImljZVNlcnZlcnMiLCJ1cmxzIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJnZXRTZW5kZXJzIiwic29tZSIsInNlbmRlciIsImFkZFRyYWNrIiwib250cmFjayIsImV2ZW50Iiwic3JjT2JqZWN0Iiwic3RyZWFtcyIsIm9uaWNlY2FuZGlkYXRlIiwiZW1pdCIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiY2xvc2UiLCJyZXNldCIsImhhbmRsZVVzZXJuYW1lQ3JlYXRlZCIsIm5ld1VzZXJuYW1lIiwic2V0SXRlbSIsInVwZGF0ZWRVc2VycyIsInN0YXJ0TXlWaWRlbyIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwidmlkZW8iLCJoYW5kbGVBY2NlcHRDYWxsIiwiY3JlYXRlQW5zd2VyIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsImxvY2FsRGVzY3JpcHRpb24iLCJoYW5kbGVSZWplY3RDYWxsIiwiaGFuZGxlRW5kQ2FsbCIsIm90aGVyVXNlciIsImZpbmQiLCJ1c2VyIiwiaGFuZGxlUmVtb3RlVmlkZW9SZWYiLCJyZWYiLCJoYW5kbGVTdHJlYW1SZWFkeSIsImhhbmRsZVVzZXJuYW1lQ2hhbmdlIiwiZm9ybWF0VGltZXIiLCJzZWNvbmRzIiwibWlucyIsIk1hdGgiLCJmbG9vciIsInNlY3MiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic3RhcnRDYWxsIiwidHJpbSIsImNyZWF0ZU9mZmVyIiwiaGFuZGxlRWRpdFVzZXIiLCJDdXN0b21FdmVudCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJjbGVhclVzZXJEYXRhIiwibG9jYXRpb24iLCJyZWxvYWQiLCJtYWluIiwiY2xhc3NOYW1lIiwiY3VycmVudFVzZXIiLCJvblN0YXJ0Q2FsbCIsIm9uRWRpdFVzZXIiLCJvblVzZXJuYW1lQ3JlYXRlZCIsIm9uRW5kQ2FsbCIsIm9uQWNjZXB0Q2FsbCIsIm9uUmVqZWN0Q2FsbCIsIm9uUmVtb3RlVmlkZW9SZWYiLCJvblN0cmVhbVJlYWR5Iiwib25Vc2VybmFtZUNoYW5nZSIsIm9uQ2xlYXJEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});