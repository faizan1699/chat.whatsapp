"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Clear any old data and start fresh\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            const handleAnswer = async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                if (pc.signalingState === \"have-local-offer\") {\n                    await pc.setRemoteDescription(answer);\n                    setRemoteDescriptionSet(true);\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in have-local-offer state, current state:\", pc.signalingState);\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            };\n            // Remove existing answer listener and add new one to prevent duplicates\n            socketRef.current.off(\"answer\");\n            socketRef.current.on(\"answer\", handleAnswer);\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                await pc.setRemoteDescription(incomingCall.offer);\n                setRemoteDescriptionSet(true);\n            } else {\n                console.error(\"Cannot set remote description: Connection not in stable state\");\n                return;\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 504,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 510,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 503,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXRnQndCdkI7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BhZ2UudHN4Pzc2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnQC9jb21wb25lbnRzL1VzZXJMaXN0JztcbmltcG9ydCBWaWRlb0NhbGwgZnJvbSAnQC9jb21wb25lbnRzL1ZpZGVvQ2FsbCc7XG5cbmludGVyZmFjZSBQZWVyQ29ubmVjdGlvbk1hbmFnZXIge1xuICBnZXRJbnN0YW5jZTogKCkgPT4gUlRDUGVlckNvbm5lY3Rpb247XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCBbdXNlcm5hbWUsIHNldFVzZXJuYW1lXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3VzZXJzLCBzZXRVc2Vyc10gPSB1c2VTdGF0ZTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pih7fSk7XG4gIGNvbnN0IFtzaG93RW5kQ2FsbEJ1dHRvbiwgc2V0U2hvd0VuZENhbGxCdXR0b25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2FsbGVyLCBzZXRDYWxsZXJdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgY29uc3QgW2luY29taW5nQ2FsbCwgc2V0SW5jb21pbmdDYWxsXSA9IHVzZVN0YXRlPHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjYWxsTm90aWZpY2F0aW9uLCBzZXRDYWxsTm90aWZpY2F0aW9uXSA9IHVzZVN0YXRlPHsgbWVzc2FnZTogc3RyaW5nOyB0eXBlOiAnc3RhcnQnIHwgJ2VuZCcgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2hvd1JlbW90ZVZpZGVvLCBzZXRTaG93UmVtb3RlVmlkZW9dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVtb3RlRGVzY3JpcHRpb25TZXQsIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0YXJ0Q2FtZXJhLCBzZXRTdGFydENhbWVyYV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYWxsVGltZXIsIHNldENhbGxUaW1lcl0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2lzQ2FsbEFjdGl2ZSwgc2V0SXNDYWxsQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Nvbm5lY3Rpb25TdGF0ZSwgc2V0Q29ubmVjdGlvblN0YXRlXSA9IHVzZVN0YXRlPCdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCc+KCdkaXNjb25uZWN0ZWQnKTtcbiAgY29uc3QgaWNlQ2FuZGlkYXRlc0J1ZmZlciA9IHVzZVJlZjxSVENJY2VDYW5kaWRhdGVJbml0W10+KFtdKTtcblxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxvY2FsU3RyZWFtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHBlZXJDb25uZWN0aW9uUmVmID0gdXNlUmVmPFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtyZW1vdGVWaWRlb0VsZW1lbnQsIHNldFJlbW90ZVZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZTxIVE1MVmlkZW9FbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVGltZXIgZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVydmFsOiBOb2RlSlMuVGltZW91dDtcbiAgICBpZiAoaXNDYWxsQWN0aXZlKSB7XG4gICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2V0Q2FsbFRpbWVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0sIFtpc0NhbGxBY3RpdmVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENsZWFyIGFueSBvbGQgZGF0YSBhbmQgc3RhcnQgZnJlc2hcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2VicnRjLXVzZXJuYW1lJyk7XG4gICAgc2V0VXNlcm5hbWUoJycpO1xuICAgIHNldFVzZXJzKHt9KTtcblxuICAgIC8vIEluaXRpYWxpemUgU29ja2V0LmlvIHNlcnZlciBmaXJzdFxuICAgIGZldGNoKCdodHRwOi8vMTkyLjE2OC4xMDAuMjQyOjMwMDAvYXBpL3NvY2tldCcpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQuaW8gc2VydmVyIGluaXRpYWxpemVkJyk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0byBTb2NrZXQuaW8gc2VydmVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBpbygnaHR0cDovLzE5Mi4xNjguMTAwLjI0MjozMDAwJywge1xuICAgICAgICAgIHBhdGg6ICcvYXBpL3NvY2tldCcsXG4gICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaDogZmFsc2UsXG4gICAgICAgICAgdHJhbnNwb3J0czogWydwb2xsaW5nJ10sIC8vIFVzZSBvbmx5IHBvbGxpbmcgdG8gYXZvaWQgV2ViU29ja2V0IGlzc3Vlc1xuICAgICAgICAgIHRpbWVvdXQ6IDIwMDAwLCAvLyBJbmNyZWFzZSB0aW1lb3V0IHRvIDIwIHNlY29uZHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byBzZXJ2ZXIgd2l0aCBJRDonLCBzb2NrZXRSZWYuY3VycmVudD8uaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGlzY29ubmVjdGVkIGZyb20gc2VydmVyJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdqb2luZWQnLCAoYWxsVXNlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQWxsIHVzZXJzIGpvaW5lZDonLCBhbGxVc2Vycyk7XG4gICAgICAgICAgc2V0VXNlcnMoYWxsVXNlcnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignb2ZmZXInLCBhc3luYyAoeyBmcm9tLCB0bywgb2ZmZXIgfTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW5jb21pbmcgY2FsbCBmcm9tOicsIGZyb20pO1xuICAgICAgICAgIC8vIFNob3cgaW5jb21pbmcgY2FsbCBub3RpZmljYXRpb24gaW5zdGVhZCBvZiBhdXRvLWFjY2VwdGluZ1xuICAgICAgICAgIHNldEluY29taW5nQ2FsbCh7IGZyb20sIHRvLCBvZmZlciB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlQW5zd2VyID0gYXN5bmMgKHsgZnJvbSwgdG8sIGFuc3dlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgYW5zd2VyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT09IFwiaGF2ZS1sb2NhbC1vZmZlclwiKSB7XG4gICAgICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiBoYXZlLWxvY2FsLW9mZmVyIHN0YXRlLCBjdXJyZW50IHN0YXRlOicsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgICAgICB3aGlsZSAoaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbih0cnVlKTtcbiAgICAgICAgICBzZXRTaG93UmVtb3RlVmlkZW8odHJ1ZSk7XG4gICAgICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgICAgIHNldENhbGxUaW1lcigwKTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgICAgLy8gU2hvdyBjYWxsIGFjY2VwdGVkIG5vdGlmaWNhdGlvbiB0byBjYWxsZXJcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt0b30gYWNjZXB0ZWQgeW91ciBjYWxsYCxcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBhbnN3ZXIgbGlzdGVuZXIgYW5kIGFkZCBuZXcgb25lIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vZmYoJ2Fuc3dlcicpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignYW5zd2VyJywgaGFuZGxlQW5zd2VyKTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBJQ0UgY2FuZGlkYXRlOicsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgcGVlciBjb25uZWN0aW9uIGlzIHJlYWR5IGZvciBJQ0UgY2FuZGlkYXRlc1xuICAgICAgICAgIGlmIChwYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiBwYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0lDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgSUNFIGNhbmRpZGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZGVzY3JpcHRpb24gbm90IHNldCB5ZXQsIGJ1ZmZlcmluZyBJQ0UgY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBCdWZmZXIgdGhlIGNhbmRpZGF0ZSB0byBhZGQgbGF0ZXJcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZW5kLWNhbGwnLCAoeyBmcm9tLCB0byB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjYWxsLWVuZGVkJywgKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgICAgICAgZW5kQ2FsbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY2FsbC1yZWplY3RlZCcsICh7IGZyb20sIHRvIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAvLyBTaG93IGNhbGwgcmVqZWN0ZWQgbm90aWZpY2F0aW9uIHRvIGNhbGxlclxuICAgICAgICAgIGlmICh0byA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmcm9tfSByZWplY3RlZCB5b3VyIGNhbGxgLFxuICAgICAgICAgICAgICB0eXBlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcm5hbWUtdGFrZW4nLCAoeyBtZXNzYWdlIH06IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlcm5hbWUgdGFrZW46JywgbWVzc2FnZSk7XG4gICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29ja2V0LmlvIHNlcnZlcjonLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBQZWVyQ29ubmVjdGlvbjogUGVlckNvbm5lY3Rpb25NYW5hZ2VyID0gKCgpID0+IHtcbiAgICBsZXQgcGVlckNvbm5lY3Rpb246IFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBjcmVhdGVQZWVyQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZyk7XG5cbiAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciB3aGVuIGNyZWF0aW5nIG5ldyBjb25uZWN0aW9uXG4gICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcblxuICAgICAgaWYgKGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBzZW5kZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICBpZiAoIXBlZXJDb25uZWN0aW9uIS5nZXRTZW5kZXJzKCkuc29tZShzZW5kZXIgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjaykpIHtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uIS5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHJlbW90ZVZpZGVvRWxlbWVudCkge1xuICAgICAgICAgIHJlbW90ZVZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBldmVudC5zdHJlYW1zWzBdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2ljZWNhbmRpZGF0ZScsIGV2ZW50LmNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQ6JywgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBnZXRJbnN0YW5jZTogKCkgPT4ge1xuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gZm9yIGVhY2ggY2FsbFxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHBlZXJDb25uZWN0aW9uID0gY3JlYXRlUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgICAgfSxcbiAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciBvbiByZXNldFxuICAgICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGhhbmRsZVVzZXJuYW1lQ3JlYXRlZCA9IChuZXdVc2VybmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHVzZXI6JywgbmV3VXNlcm5hbWUpO1xuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3ZWJydGMtdXNlcm5hbWUnLCBuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gQWRkIGN1cnJlbnQgdXNlciB0byBsb2NhbCBsaXN0IGltbWVkaWF0ZWx5IGZvciBiZXR0ZXIgVVhcbiAgICBzZXRVc2VycyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VycyA9IHsgLi4ucHJldiwgW25ld1VzZXJuYW1lXTogbmV3VXNlcm5hbWUgfTtcbiAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCB1c2VycyB1cGRhdGVkOicsIHVwZGF0ZWRVc2Vycyk7XG4gICAgICByZXR1cm4gdXBkYXRlZFVzZXJzO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEVtaXQgdG8gc2VydmVyIHRvIHN5bmMgd2l0aCBvdGhlciBkZXZpY2VzXG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdqb2luLXVzZXInLCBuZXdVc2VybmFtZSk7XG4gICAgICBjb25zb2xlLmxvZygnRW1pdHRlZCBqb2luLXVzZXIgZXZlbnQgZm9yOicsIG5ld1VzZXJuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRNeVZpZGVvID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgIGNvbnNvbGUubG9nKHsgc3RyZWFtIH0pO1xuICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudCA9IHN0cmVhbTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIG1lZGlhIGRldmljZXM6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmRDYWxsID0gKCkgPT4ge1xuICAgIFBlZXJDb25uZWN0aW9uLnJlc2V0KCk7XG4gICAgc2V0U2hvd0VuZENhbGxCdXR0b24oZmFsc2UpO1xuICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQoZmFsc2UpO1xuICAgIHNldFN0YXJ0Q2FtZXJhKGZhbHNlKTtcbiAgICBzZXRJc0NhbGxBY3RpdmUoZmFsc2UpO1xuICAgIHNldENhbGxUaW1lcigwKTtcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudCA9IFtdO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUFjY2VwdENhbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpbmNvbWluZ0NhbGwpIHJldHVybjtcblxuICAgIC8vIFN0YXJ0IGNhbWVyYSB3aGVuIGFjY2VwdGluZyBhIGNhbGxcbiAgICBzZXRTdGFydENhbWVyYSh0cnVlKTtcblxuICAgIC8vIFdhaXQgYSBiaXQgZm9yIGNhbWVyYSB0byBzdGFydFxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihpbmNvbWluZ0NhbGwub2ZmZXIpO1xuICAgICAgICBzZXRSZW1vdGVEZXNjcmlwdGlvblNldCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiBzdGFibGUgc3RhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgIHdoaWxlIChpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5IGluIGhhbmRsZUFjY2VwdENhbGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGUgaW4gaGFuZGxlQWNjZXB0Q2FsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBhd2FpdCBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cbiAgICAgIC8vIEFkZCBsb2NhbCBzdHJlYW0gdG8gcGVlciBjb25uZWN0aW9uXG4gICAgICBpZiAobG9jYWxTdHJlYW1SZWYuY3VycmVudCkge1xuICAgICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbmRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIGlmICghcGMuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdhbnN3ZXInLCB7XG4gICAgICAgIGZyb206IGluY29taW5nQ2FsbC50byxcbiAgICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tLFxuICAgICAgICBhbnN3ZXI6IHBjLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgIH0pO1xuXG4gICAgICBzZXRDYWxsZXIoW2luY29taW5nQ2FsbC5mcm9tLCBpbmNvbWluZ0NhbGwudG9dKTtcbiAgICAgIHNldEluY29taW5nQ2FsbChudWxsKTtcbiAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgLy8gU2hvdyBjYWxsIHN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYWxsIHN0YXJ0ZWQgd2l0aCAke2luY29taW5nQ2FsbC5mcm9tfWAsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIG5vdGlmaWNhdGlvbiBhZnRlciAzIHNlY29uZHNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVqZWN0Q2FsbCA9ICgpID0+IHtcbiAgICBpZiAoIWluY29taW5nQ2FsbCkgcmV0dXJuO1xuXG4gICAgLy8gTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCBjYWxsIHdhcyByZWplY3RlZFxuICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdjYWxsLXJlamVjdGVkJywge1xuICAgICAgZnJvbTogaW5jb21pbmdDYWxsLnRvLFxuICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tXG4gICAgfSk7XG5cbiAgICBzZXRJbmNvbWluZ0NhbGwobnVsbCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRW5kQ2FsbCA9ICgpID0+IHtcbiAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnY2FsbC1lbmRlZCcsIGNhbGxlcik7XG5cbiAgICAvLyBTaG93IGNhbGwgZW5kIG5vdGlmaWNhdGlvblxuICAgIGNvbnN0IG90aGVyVXNlciA9IGNhbGxlci5maW5kKHVzZXIgPT4gdXNlciAhPT0gdXNlcm5hbWUpO1xuICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgbWVzc2FnZTogYENhbGwgZW5kZWQgd2l0aCAke290aGVyVXNlcn1gLFxuICAgICAgdHlwZTogJ2VuZCdcbiAgICB9KTtcblxuICAgIC8vIEhpZGUgbm90aWZpY2F0aW9uIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVSZW1vdGVWaWRlb1JlZiA9IChyZWY6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVtb3RlVmlkZW9FbGVtZW50KHJlZik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU3RyZWFtUmVhZHkgPSAoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVXNlcm5hbWVDaGFuZ2UgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB3aXRoIG5ldyB1c2VybmFtZVxuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIGNoYW5nZWQgdG86JywgbmV3VXNlcm5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmb3JtYXRUaW1lciA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBzZWNvbmRzICUgNjA7XG4gICAgcmV0dXJuIGAke21pbnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRDYWxsID0gYXN5bmMgKHVzZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKHsgdXNlciB9KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgaWYgKCF1c2VybmFtZSB8fCB1c2VybmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBjcmVhdGUgYSB1c2VybmFtZSBmaXJzdCcsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpLCAzMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0YXJnZXQgdXNlciBleGlzdHNcbiAgICBpZiAoIXVzZXJzW3VzZXJdKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBUYXJnZXQgdXNlciBub3QgZm91bmQnKTtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiBgVXNlciAke3VzZXJ9IGlzIG5vdCBhdmFpbGFibGVgLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKSwgMzAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXRlIHRvIGNvbm5lY3RpbmdcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICBcbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBtYWtpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG4gICAgXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FtZXJhIHRvIHN0YXJ0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICBjb25zb2xlLmxvZyh7IG9mZmVyIH0pO1xuICAgICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnb2ZmZXInLCB7IGZyb206IHVzZXJuYW1lLCB0bzogdXNlciwgb2ZmZXI6IHBjLmxvY2FsRGVzY3JpcHRpb24gfSk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRWRpdFVzZXIgPSAoKSA9PiB7XG4gICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGVkaXQgbW9kYWwgaW4gVmlkZW9DYWxsIGNvbXBvbmVudFxuICAgIC8vIFdlJ2xsIHVzZSBhIHN0YXRlIHRvIGNvbW11bmljYXRlIGJldHdlZW4gY29tcG9uZW50c1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdvcGVuRWRpdE1vZGFsJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyVXNlckRhdGEgPSAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgIHNldFVzZXJuYW1lKCcnKTtcbiAgICBzZXRVc2Vycyh7fSk7XG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDbGVhciBhbGwgdXNlcnMgZnJvbSBzZXJ2ZXJcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2NsZWFyLWFsbC11c2VycycpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gUmVjb25uZWN0IGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJoLXNjcmVlbiBmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93XCI+XG4gICAgICA8VXNlckxpc3RcbiAgICAgICAgdXNlcnM9e3VzZXJzfVxuICAgICAgICBjdXJyZW50VXNlcj17dXNlcm5hbWV9XG4gICAgICAgIG9uU3RhcnRDYWxsPXtzdGFydENhbGx9XG4gICAgICAgIG9uRWRpdFVzZXI9e2hhbmRsZUVkaXRVc2VyfVxuICAgICAgLz5cbiAgICAgIDxWaWRlb0NhbGxcbiAgICAgICAgdXNlcm5hbWU9e3VzZXJuYW1lfVxuICAgICAgICBvblVzZXJuYW1lQ3JlYXRlZD17aGFuZGxlVXNlcm5hbWVDcmVhdGVkfVxuICAgICAgICBvbkVuZENhbGw9e2hhbmRsZUVuZENhbGx9XG4gICAgICAgIHNob3dFbmRDYWxsQnV0dG9uPXtzaG93RW5kQ2FsbEJ1dHRvbn1cbiAgICAgICAgaW5jb21pbmdDYWxsPXtpbmNvbWluZ0NhbGx9XG4gICAgICAgIG9uQWNjZXB0Q2FsbD17aGFuZGxlQWNjZXB0Q2FsbH1cbiAgICAgICAgb25SZWplY3RDYWxsPXtoYW5kbGVSZWplY3RDYWxsfVxuICAgICAgICBjYWxsTm90aWZpY2F0aW9uPXtjYWxsTm90aWZpY2F0aW9ufVxuICAgICAgICBvblJlbW90ZVZpZGVvUmVmPXtoYW5kbGVSZW1vdGVWaWRlb1JlZn1cbiAgICAgICAgc2hvd1JlbW90ZVZpZGVvPXtzaG93UmVtb3RlVmlkZW99XG4gICAgICAgIHN0YXJ0Q2FtZXJhPXtzdGFydENhbWVyYX1cbiAgICAgICAgb25TdHJlYW1SZWFkeT17aGFuZGxlU3RyZWFtUmVhZHl9XG4gICAgICAgIGNhbGxUaW1lcj17Y2FsbFRpbWVyfVxuICAgICAgICBpc0NhbGxBY3RpdmU9e2lzQ2FsbEFjdGl2ZX1cbiAgICAgICAgb25Vc2VybmFtZUNoYW5nZT17aGFuZGxlVXNlcm5hbWVDaGFuZ2V9XG4gICAgICAgIG9uQ2xlYXJEYXRhPXtjbGVhclVzZXJEYXRhfVxuICAgICAgICBjb25uZWN0aW9uU3RhdGU9e2Nvbm5lY3Rpb25TdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9tYWluPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaW8iLCJVc2VyTGlzdCIsIlZpZGVvQ2FsbCIsIkhvbWUiLCJ1c2VybmFtZSIsInNldFVzZXJuYW1lIiwidXNlcnMiLCJzZXRVc2VycyIsInNob3dFbmRDYWxsQnV0dG9uIiwic2V0U2hvd0VuZENhbGxCdXR0b24iLCJjYWxsZXIiLCJzZXRDYWxsZXIiLCJpbmNvbWluZ0NhbGwiLCJzZXRJbmNvbWluZ0NhbGwiLCJjYWxsTm90aWZpY2F0aW9uIiwic2V0Q2FsbE5vdGlmaWNhdGlvbiIsInNob3dSZW1vdGVWaWRlbyIsInNldFNob3dSZW1vdGVWaWRlbyIsInJlbW90ZURlc2NyaXB0aW9uU2V0Iiwic2V0UmVtb3RlRGVzY3JpcHRpb25TZXQiLCJzdGFydENhbWVyYSIsInNldFN0YXJ0Q2FtZXJhIiwiY2FsbFRpbWVyIiwic2V0Q2FsbFRpbWVyIiwiaXNDYWxsQWN0aXZlIiwic2V0SXNDYWxsQWN0aXZlIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwiaWNlQ2FuZGlkYXRlc0J1ZmZlciIsInNvY2tldFJlZiIsImxvY2FsU3RyZWFtUmVmIiwicGVlckNvbm5lY3Rpb25SZWYiLCJyZW1vdGVWaWRlb0VsZW1lbnQiLCJzZXRSZW1vdGVWaWRlb0VsZW1lbnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHJldiIsImNsZWFySW50ZXJ2YWwiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiZmV0Y2giLCJ0aGVuIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJwYXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0Iiwib24iLCJpZCIsImVycm9yIiwiYWxsVXNlcnMiLCJmcm9tIiwidG8iLCJvZmZlciIsImhhbmRsZUFuc3dlciIsImFuc3dlciIsInBjIiwiUGVlckNvbm5lY3Rpb24iLCJnZXRJbnN0YW5jZSIsInNpZ25hbGluZ1N0YXRlIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJsZW5ndGgiLCJjYW5kaWRhdGUiLCJzaGlmdCIsImFkZEljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsIm1lc3NhZ2UiLCJ0eXBlIiwic2V0VGltZW91dCIsIm9mZiIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsImVuZENhbGwiLCJjYXRjaCIsImRpc2Nvbm5lY3QiLCJwZWVyQ29ubmVjdGlvbiIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwiY29uZmlnIiwiaWNlU2VydmVycyIsInVybHMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImdldFNlbmRlcnMiLCJzb21lIiwic2VuZGVyIiwiYWRkVHJhY2siLCJvbnRyYWNrIiwiZXZlbnQiLCJzcmNPYmplY3QiLCJzdHJlYW1zIiwib25pY2VjYW5kaWRhdGUiLCJlbWl0Iiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJjbG9zZSIsInJlc2V0IiwiaGFuZGxlVXNlcm5hbWVDcmVhdGVkIiwibmV3VXNlcm5hbWUiLCJzZXRJdGVtIiwidXBkYXRlZFVzZXJzIiwic3RhcnRNeVZpZGVvIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ2aWRlbyIsImhhbmRsZUFjY2VwdENhbGwiLCJjcmVhdGVBbnN3ZXIiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImhhbmRsZVJlamVjdENhbGwiLCJoYW5kbGVFbmRDYWxsIiwib3RoZXJVc2VyIiwiZmluZCIsInVzZXIiLCJoYW5kbGVSZW1vdGVWaWRlb1JlZiIsInJlZiIsImhhbmRsZVN0cmVhbVJlYWR5IiwiaGFuZGxlVXNlcm5hbWVDaGFuZ2UiLCJmb3JtYXRUaW1lciIsInNlY29uZHMiLCJtaW5zIiwiTWF0aCIsImZsb29yIiwic2VjcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydENhbGwiLCJ0cmltIiwiY3JlYXRlT2ZmZXIiLCJoYW5kbGVFZGl0VXNlciIsIkN1c3RvbUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsImNsZWFyVXNlckRhdGEiLCJsb2NhdGlvbiIsInJlbG9hZCIsIm1haW4iLCJjbGFzc05hbWUiLCJjdXJyZW50VXNlciIsIm9uU3RhcnRDYWxsIiwib25FZGl0VXNlciIsIm9uVXNlcm5hbWVDcmVhdGVkIiwib25FbmRDYWxsIiwib25BY2NlcHRDYWxsIiwib25SZWplY3RDYWxsIiwib25SZW1vdGVWaWRlb1JlZiIsIm9uU3RyZWFtUmVhZHkiLCJvblVzZXJuYW1lQ2hhbmdlIiwib25DbGVhckRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});