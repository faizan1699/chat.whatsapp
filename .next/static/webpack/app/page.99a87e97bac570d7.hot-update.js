"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Clear any old data and start fresh\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            socketRef.current.on(\"answer\", async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                if (pc.signalingState === \"stable\") {\n                    await pc.setRemoteDescription(answer);\n                    setRemoteDescriptionSet(true);\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in stable state\");\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                await pc.setRemoteDescription(incomingCall.offer);\n                setRemoteDescriptionSet(true);\n            } else {\n                console.error(\"Cannot set remote description: Connection not in stable state\");\n                return;\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 500,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 506,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 499,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxHQUFHc0QsZ0JBQWdCO1lBQUM7UUFDMUYsR0FBRztJQUNMO0lBRUEsTUFBTXFCLGlCQUFpQjtRQUNyQiwwREFBMEQ7UUFDMUQsc0RBQXNEO1FBQ3RELE1BQU0zQyxRQUFRLElBQUk0QyxZQUFZO1FBQzlCQyxPQUFPQyxhQUFhLENBQUM5QztJQUN2QjtJQUVBLE1BQU0rQyxnQkFBZ0I7UUFDcEJsRyxhQUFhQyxVQUFVLENBQUM7UUFDeEJsQyxZQUFZO1FBQ1pFLFNBQVMsQ0FBQztRQUNWLElBQUlzQixVQUFVZSxPQUFPLEVBQUU7WUFDckIsOEJBQThCO1lBQzlCZixVQUFVZSxPQUFPLENBQUNpRCxJQUFJLENBQUM7WUFDdkJoRSxVQUFVZSxPQUFPLENBQUM4QixVQUFVO1lBQzVCLGdDQUFnQztZQUNoQ0wsV0FBVztnQkFDVGlFLE9BQU9HLFFBQVEsQ0FBQ0MsTUFBTTtZQUN4QixHQUFHO1FBQ0w7SUFDRjtJQUVBLHFCQUNFLDhEQUFDQztRQUFLQyxXQUFVOzswQkFDZCw4REFBQzNJLDREQUFRQTtnQkFDUEssT0FBT0E7Z0JBQ1B1SSxhQUFhekk7Z0JBQ2IwSSxhQUFhYjtnQkFDYmMsWUFBWVg7Ozs7OzswQkFFZCw4REFBQ2xJLDZEQUFTQTtnQkFDUkUsVUFBVUE7Z0JBQ1Y0SSxtQkFBbUIvQztnQkFDbkJnRCxXQUFXaEM7Z0JBQ1h6RyxtQkFBbUJBO2dCQUNuQkksY0FBY0E7Z0JBQ2RzSSxjQUFjdEM7Z0JBQ2R1QyxjQUFjbkM7Z0JBQ2RsRyxrQkFBa0JBO2dCQUNsQnNJLGtCQUFrQi9CO2dCQUNsQnJHLGlCQUFpQkE7Z0JBQ2pCSSxhQUFhQTtnQkFDYmlJLGVBQWU5QjtnQkFDZmpHLFdBQVdBO2dCQUNYRSxjQUFjQTtnQkFDZDhILGtCQUFrQjlCO2dCQUNsQitCLGFBQWFmO2dCQUNiOUcsaUJBQWlCQTs7Ozs7Ozs7Ozs7O0FBSXpCO0dBbGdCd0J2QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBVc2VyTGlzdCBmcm9tICdAL2NvbXBvbmVudHMvVXNlckxpc3QnO1xuaW1wb3J0IFZpZGVvQ2FsbCBmcm9tICdAL2NvbXBvbmVudHMvVmlkZW9DYWxsJztcblxuaW50ZXJmYWNlIFBlZXJDb25uZWN0aW9uTWFuYWdlciB7XG4gIGdldEluc3RhbmNlOiAoKSA9PiBSVENQZWVyQ29ubmVjdGlvbjtcbiAgcmVzZXQ6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFt1c2VybmFtZSwgc2V0VXNlcm5hbWVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+KHt9KTtcbiAgY29uc3QgW3Nob3dFbmRDYWxsQnV0dG9uLCBzZXRTaG93RW5kQ2FsbEJ1dHRvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYWxsZXIsIHNldENhbGxlcl0gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbaW5jb21pbmdDYWxsLCBzZXRJbmNvbWluZ0NhbGxdID0gdXNlU3RhdGU8eyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NhbGxOb3RpZmljYXRpb24sIHNldENhbGxOb3RpZmljYXRpb25dID0gdXNlU3RhdGU8eyBtZXNzYWdlOiBzdHJpbmc7IHR5cGU6ICdzdGFydCcgfCAnZW5kJyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93UmVtb3RlVmlkZW8sIHNldFNob3dSZW1vdGVWaWRlb10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZW1vdGVEZXNjcmlwdGlvblNldCwgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhcnRDYW1lcmEsIHNldFN0YXJ0Q2FtZXJhXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhbGxUaW1lciwgc2V0Q2FsbFRpbWVyXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbaXNDYWxsQWN0aXZlLCBzZXRJc0NhbGxBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8J2Nvbm5lY3RpbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJz4oJ2Rpc2Nvbm5lY3RlZCcpO1xuICBjb25zdCBpY2VDYW5kaWRhdGVzQnVmZmVyID0gdXNlUmVmPFJUQ0ljZUNhbmRpZGF0ZUluaXRbXT4oW10pO1xuXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9jYWxTdHJlYW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgcGVlckNvbm5lY3Rpb25SZWYgPSB1c2VSZWY8UlRDUGVlckNvbm5lY3Rpb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3JlbW90ZVZpZGVvRWxlbWVudCwgc2V0UmVtb3RlVmlkZW9FbGVtZW50XSA9IHVzZVN0YXRlPEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICAvLyBUaW1lciBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0O1xuICAgIGlmIChpc0NhbGxBY3RpdmUpIHtcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsVGltZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpbnRlcnZhbCkgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgfTtcbiAgfSwgW2lzQ2FsbEFjdGl2ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgYW55IG9sZCBkYXRhIGFuZCBzdGFydCBmcmVzaFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3ZWJydGMtdXNlcm5hbWUnKTtcbiAgICBzZXRVc2VybmFtZSgnJyk7XG4gICAgc2V0VXNlcnMoe30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBTb2NrZXQuaW8gc2VydmVyIGZpcnN0XG4gICAgZmV0Y2goJ2h0dHA6Ly8xOTIuMTY4LjEwMC4yNDI6MzAwMC9hcGkvc29ja2V0JylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NvY2tldC5pbyBzZXJ2ZXIgaW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAvLyBDb25uZWN0IHRvIFNvY2tldC5pbyBzZXJ2ZXIgd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKCdodHRwOi8vMTkyLjE2OC4xMDAuMjQyOjMwMDAnLCB7XG4gICAgICAgICAgcGF0aDogJy9hcGkvc29ja2V0JyxcbiAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoOiBmYWxzZSxcbiAgICAgICAgICB0cmFuc3BvcnRzOiBbJ3BvbGxpbmcnXSwgLy8gVXNlIG9ubHkgcG9sbGluZyB0byBhdm9pZCBXZWJTb2NrZXQgaXNzdWVzXG4gICAgICAgICAgdGltZW91dDogMjAwMDAsIC8vIEluY3JlYXNlIHRpbWVvdXQgdG8gMjAgc2Vjb25kc1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHNlcnZlciB3aXRoIElEOicsIHNvY2tldFJlZi5jdXJyZW50Py5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2pvaW5lZCcsIChhbGxVc2VyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgdXNlcnMgam9pbmVkOicsIGFsbFVzZXJzKTtcbiAgICAgICAgICBzZXRVc2VycyhhbGxVc2Vycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdvZmZlcicsIGFzeW5jICh7IGZyb20sIHRvLCBvZmZlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgb2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbmNvbWluZyBjYWxsIGZyb206JywgZnJvbSk7XG4gICAgICAgICAgLy8gU2hvdyBpbmNvbWluZyBjYWxsIG5vdGlmaWNhdGlvbiBpbnN0ZWFkIG9mIGF1dG8tYWNjZXB0aW5nXG4gICAgICAgICAgc2V0SW5jb21pbmdDYWxsKHsgZnJvbSwgdG8sIG9mZmVyIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignYW5zd2VyJywgYXN5bmMgKHsgZnJvbSwgdG8sIGFuc3dlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgYW5zd2VyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiBzdGFibGUgc3RhdGUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgICAgICB3aGlsZSAoaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBidWZmZXJlZCBJQ0UgY2FuZGlkYXRlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRTaG93RW5kQ2FsbEJ1dHRvbih0cnVlKTtcbiAgICAgICAgICBzZXRTaG93UmVtb3RlVmlkZW8odHJ1ZSk7XG4gICAgICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgICAgIHNldENhbGxUaW1lcigwKTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgICAgLy8gU2hvdyBjYWxsIGFjY2VwdGVkIG5vdGlmaWNhdGlvbiB0byBjYWxsZXJcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt0b30gYWNjZXB0ZWQgeW91ciBjYWxsYCxcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBJQ0UgY2FuZGlkYXRlOicsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgcGVlciBjb25uZWN0aW9uIGlzIHJlYWR5IGZvciBJQ0UgY2FuZGlkYXRlc1xuICAgICAgICAgIGlmIChwYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiBwYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwYy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0lDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgSUNFIGNhbmRpZGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZGVzY3JpcHRpb24gbm90IHNldCB5ZXQsIGJ1ZmZlcmluZyBJQ0UgY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBCdWZmZXIgdGhlIGNhbmRpZGF0ZSB0byBhZGQgbGF0ZXJcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZW5kLWNhbGwnLCAoeyBmcm9tLCB0byB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjYWxsLWVuZGVkJywgKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgICAgICAgZW5kQ2FsbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY2FsbC1yZWplY3RlZCcsICh7IGZyb20sIHRvIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAvLyBTaG93IGNhbGwgcmVqZWN0ZWQgbm90aWZpY2F0aW9uIHRvIGNhbGxlclxuICAgICAgICAgIGlmICh0byA9PT0gdXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmcm9tfSByZWplY3RlZCB5b3VyIGNhbGxgLFxuICAgICAgICAgICAgICB0eXBlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcm5hbWUtdGFrZW4nLCAoeyBtZXNzYWdlIH06IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlcm5hbWUgdGFrZW46JywgbWVzc2FnZSk7XG4gICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29ja2V0LmlvIHNlcnZlcjonLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBQZWVyQ29ubmVjdGlvbjogUGVlckNvbm5lY3Rpb25NYW5hZ2VyID0gKCgpID0+IHtcbiAgICBsZXQgcGVlckNvbm5lY3Rpb246IFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBjcmVhdGVQZWVyQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZyk7XG5cbiAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciB3aGVuIGNyZWF0aW5nIG5ldyBjb25uZWN0aW9uXG4gICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcblxuICAgICAgaWYgKGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBzZW5kZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICBpZiAoIXBlZXJDb25uZWN0aW9uIS5nZXRTZW5kZXJzKCkuc29tZShzZW5kZXIgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjaykpIHtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uIS5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHJlbW90ZVZpZGVvRWxlbWVudCkge1xuICAgICAgICAgIHJlbW90ZVZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBldmVudC5zdHJlYW1zWzBdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2ljZWNhbmRpZGF0ZScsIGV2ZW50LmNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBlZXJDb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQ6JywgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgcGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBnZXRJbnN0YW5jZTogKCkgPT4ge1xuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gZm9yIGVhY2ggY2FsbFxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHBlZXJDb25uZWN0aW9uID0gY3JlYXRlUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgICAgfSxcbiAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIElDRSBjYW5kaWRhdGVzIGJ1ZmZlciBvbiByZXNldFxuICAgICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGhhbmRsZVVzZXJuYW1lQ3JlYXRlZCA9IChuZXdVc2VybmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHVzZXI6JywgbmV3VXNlcm5hbWUpO1xuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3ZWJydGMtdXNlcm5hbWUnLCBuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gQWRkIGN1cnJlbnQgdXNlciB0byBsb2NhbCBsaXN0IGltbWVkaWF0ZWx5IGZvciBiZXR0ZXIgVVhcbiAgICBzZXRVc2VycyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VycyA9IHsgLi4ucHJldiwgW25ld1VzZXJuYW1lXTogbmV3VXNlcm5hbWUgfTtcbiAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCB1c2VycyB1cGRhdGVkOicsIHVwZGF0ZWRVc2Vycyk7XG4gICAgICByZXR1cm4gdXBkYXRlZFVzZXJzO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEVtaXQgdG8gc2VydmVyIHRvIHN5bmMgd2l0aCBvdGhlciBkZXZpY2VzXG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdqb2luLXVzZXInLCBuZXdVc2VybmFtZSk7XG4gICAgICBjb25zb2xlLmxvZygnRW1pdHRlZCBqb2luLXVzZXIgZXZlbnQgZm9yOicsIG5ld1VzZXJuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRNeVZpZGVvID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgIGNvbnNvbGUubG9nKHsgc3RyZWFtIH0pO1xuICAgICAgbG9jYWxTdHJlYW1SZWYuY3VycmVudCA9IHN0cmVhbTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIG1lZGlhIGRldmljZXM6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmRDYWxsID0gKCkgPT4ge1xuICAgIFBlZXJDb25uZWN0aW9uLnJlc2V0KCk7XG4gICAgc2V0U2hvd0VuZENhbGxCdXR0b24oZmFsc2UpO1xuICAgIHNldFNob3dSZW1vdGVWaWRlbyhmYWxzZSk7XG4gICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQoZmFsc2UpO1xuICAgIHNldFN0YXJ0Q2FtZXJhKGZhbHNlKTtcbiAgICBzZXRJc0NhbGxBY3RpdmUoZmFsc2UpO1xuICAgIHNldENhbGxUaW1lcigwKTtcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudCA9IFtdO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUFjY2VwdENhbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpbmNvbWluZ0NhbGwpIHJldHVybjtcblxuICAgIC8vIFN0YXJ0IGNhbWVyYSB3aGVuIGFjY2VwdGluZyBhIGNhbGxcbiAgICBzZXRTdGFydENhbWVyYSh0cnVlKTtcblxuICAgIC8vIFdhaXQgYSBiaXQgZm9yIGNhbWVyYSB0byBzdGFydFxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGMgPSBQZWVyQ29ubmVjdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihpbmNvbWluZ0NhbGwub2ZmZXIpO1xuICAgICAgICBzZXRSZW1vdGVEZXNjcmlwdGlvblNldCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiBzdGFibGUgc3RhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgIHdoaWxlIChpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5IGluIGhhbmRsZUFjY2VwdENhbGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGUgaW4gaGFuZGxlQWNjZXB0Q2FsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBhd2FpdCBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cbiAgICAgIC8vIEFkZCBsb2NhbCBzdHJlYW0gdG8gcGVlciBjb25uZWN0aW9uXG4gICAgICBpZiAobG9jYWxTdHJlYW1SZWYuY3VycmVudCkge1xuICAgICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbmRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIGlmICghcGMuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdhbnN3ZXInLCB7XG4gICAgICAgIGZyb206IGluY29taW5nQ2FsbC50byxcbiAgICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tLFxuICAgICAgICBhbnN3ZXI6IHBjLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgIH0pO1xuXG4gICAgICBzZXRDYWxsZXIoW2luY29taW5nQ2FsbC5mcm9tLCBpbmNvbWluZ0NhbGwudG9dKTtcbiAgICAgIHNldEluY29taW5nQ2FsbChudWxsKTtcbiAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgLy8gU2hvdyBjYWxsIHN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYWxsIHN0YXJ0ZWQgd2l0aCAke2luY29taW5nQ2FsbC5mcm9tfWAsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIG5vdGlmaWNhdGlvbiBhZnRlciAzIHNlY29uZHNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVqZWN0Q2FsbCA9ICgpID0+IHtcbiAgICBpZiAoIWluY29taW5nQ2FsbCkgcmV0dXJuO1xuXG4gICAgLy8gTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCBjYWxsIHdhcyByZWplY3RlZFxuICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdjYWxsLXJlamVjdGVkJywge1xuICAgICAgZnJvbTogaW5jb21pbmdDYWxsLnRvLFxuICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tXG4gICAgfSk7XG5cbiAgICBzZXRJbmNvbWluZ0NhbGwobnVsbCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRW5kQ2FsbCA9ICgpID0+IHtcbiAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnY2FsbC1lbmRlZCcsIGNhbGxlcik7XG5cbiAgICAvLyBTaG93IGNhbGwgZW5kIG5vdGlmaWNhdGlvblxuICAgIGNvbnN0IG90aGVyVXNlciA9IGNhbGxlci5maW5kKHVzZXIgPT4gdXNlciAhPT0gdXNlcm5hbWUpO1xuICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgbWVzc2FnZTogYENhbGwgZW5kZWQgd2l0aCAke290aGVyVXNlcn1gLFxuICAgICAgdHlwZTogJ2VuZCdcbiAgICB9KTtcblxuICAgIC8vIEhpZGUgbm90aWZpY2F0aW9uIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVSZW1vdGVWaWRlb1JlZiA9IChyZWY6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVtb3RlVmlkZW9FbGVtZW50KHJlZik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU3RyZWFtUmVhZHkgPSAoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVXNlcm5hbWVDaGFuZ2UgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB3aXRoIG5ldyB1c2VybmFtZVxuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIGNoYW5nZWQgdG86JywgbmV3VXNlcm5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmb3JtYXRUaW1lciA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBzZWNvbmRzICUgNjA7XG4gICAgcmV0dXJuIGAke21pbnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRDYWxsID0gYXN5bmMgKHVzZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKHsgdXNlciB9KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgaWYgKCF1c2VybmFtZSB8fCB1c2VybmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBjcmVhdGUgYSB1c2VybmFtZSBmaXJzdCcsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpLCAzMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0YXJnZXQgdXNlciBleGlzdHNcbiAgICBpZiAoIXVzZXJzW3VzZXJdKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBUYXJnZXQgdXNlciBub3QgZm91bmQnKTtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiBgVXNlciAke3VzZXJ9IGlzIG5vdCBhdmFpbGFibGVgLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKSwgMzAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXRlIHRvIGNvbm5lY3RpbmdcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICBcbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBtYWtpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG4gICAgXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FtZXJhIHRvIHN0YXJ0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICBjb25zb2xlLmxvZyh7IG9mZmVyIH0pO1xuICAgICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnb2ZmZXInLCB7IGZyb206IHVzZXJuYW1lLCB0bzogdXNlciwgb2ZmZXI6IHBjLmxvY2FsRGVzY3JpcHRpb24gfSk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRWRpdFVzZXIgPSAoKSA9PiB7XG4gICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGVkaXQgbW9kYWwgaW4gVmlkZW9DYWxsIGNvbXBvbmVudFxuICAgIC8vIFdlJ2xsIHVzZSBhIHN0YXRlIHRvIGNvbW11bmljYXRlIGJldHdlZW4gY29tcG9uZW50c1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdvcGVuRWRpdE1vZGFsJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyVXNlckRhdGEgPSAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgIHNldFVzZXJuYW1lKCcnKTtcbiAgICBzZXRVc2Vycyh7fSk7XG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDbGVhciBhbGwgdXNlcnMgZnJvbSBzZXJ2ZXJcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2NsZWFyLWFsbC11c2VycycpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gUmVjb25uZWN0IGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJoLXNjcmVlbiBmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93XCI+XG4gICAgICA8VXNlckxpc3RcbiAgICAgICAgdXNlcnM9e3VzZXJzfVxuICAgICAgICBjdXJyZW50VXNlcj17dXNlcm5hbWV9XG4gICAgICAgIG9uU3RhcnRDYWxsPXtzdGFydENhbGx9XG4gICAgICAgIG9uRWRpdFVzZXI9e2hhbmRsZUVkaXRVc2VyfVxuICAgICAgLz5cbiAgICAgIDxWaWRlb0NhbGxcbiAgICAgICAgdXNlcm5hbWU9e3VzZXJuYW1lfVxuICAgICAgICBvblVzZXJuYW1lQ3JlYXRlZD17aGFuZGxlVXNlcm5hbWVDcmVhdGVkfVxuICAgICAgICBvbkVuZENhbGw9e2hhbmRsZUVuZENhbGx9XG4gICAgICAgIHNob3dFbmRDYWxsQnV0dG9uPXtzaG93RW5kQ2FsbEJ1dHRvbn1cbiAgICAgICAgaW5jb21pbmdDYWxsPXtpbmNvbWluZ0NhbGx9XG4gICAgICAgIG9uQWNjZXB0Q2FsbD17aGFuZGxlQWNjZXB0Q2FsbH1cbiAgICAgICAgb25SZWplY3RDYWxsPXtoYW5kbGVSZWplY3RDYWxsfVxuICAgICAgICBjYWxsTm90aWZpY2F0aW9uPXtjYWxsTm90aWZpY2F0aW9ufVxuICAgICAgICBvblJlbW90ZVZpZGVvUmVmPXtoYW5kbGVSZW1vdGVWaWRlb1JlZn1cbiAgICAgICAgc2hvd1JlbW90ZVZpZGVvPXtzaG93UmVtb3RlVmlkZW99XG4gICAgICAgIHN0YXJ0Q2FtZXJhPXtzdGFydENhbWVyYX1cbiAgICAgICAgb25TdHJlYW1SZWFkeT17aGFuZGxlU3RyZWFtUmVhZHl9XG4gICAgICAgIGNhbGxUaW1lcj17Y2FsbFRpbWVyfVxuICAgICAgICBpc0NhbGxBY3RpdmU9e2lzQ2FsbEFjdGl2ZX1cbiAgICAgICAgb25Vc2VybmFtZUNoYW5nZT17aGFuZGxlVXNlcm5hbWVDaGFuZ2V9XG4gICAgICAgIG9uQ2xlYXJEYXRhPXtjbGVhclVzZXJEYXRhfVxuICAgICAgICBjb25uZWN0aW9uU3RhdGU9e2Nvbm5lY3Rpb25TdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9tYWluPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaW8iLCJVc2VyTGlzdCIsIlZpZGVvQ2FsbCIsIkhvbWUiLCJ1c2VybmFtZSIsInNldFVzZXJuYW1lIiwidXNlcnMiLCJzZXRVc2VycyIsInNob3dFbmRDYWxsQnV0dG9uIiwic2V0U2hvd0VuZENhbGxCdXR0b24iLCJjYWxsZXIiLCJzZXRDYWxsZXIiLCJpbmNvbWluZ0NhbGwiLCJzZXRJbmNvbWluZ0NhbGwiLCJjYWxsTm90aWZpY2F0aW9uIiwic2V0Q2FsbE5vdGlmaWNhdGlvbiIsInNob3dSZW1vdGVWaWRlbyIsInNldFNob3dSZW1vdGVWaWRlbyIsInJlbW90ZURlc2NyaXB0aW9uU2V0Iiwic2V0UmVtb3RlRGVzY3JpcHRpb25TZXQiLCJzdGFydENhbWVyYSIsInNldFN0YXJ0Q2FtZXJhIiwiY2FsbFRpbWVyIiwic2V0Q2FsbFRpbWVyIiwiaXNDYWxsQWN0aXZlIiwic2V0SXNDYWxsQWN0aXZlIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwiaWNlQ2FuZGlkYXRlc0J1ZmZlciIsInNvY2tldFJlZiIsImxvY2FsU3RyZWFtUmVmIiwicGVlckNvbm5lY3Rpb25SZWYiLCJyZW1vdGVWaWRlb0VsZW1lbnQiLCJzZXRSZW1vdGVWaWRlb0VsZW1lbnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHJldiIsImNsZWFySW50ZXJ2YWwiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiZmV0Y2giLCJ0aGVuIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJwYXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0Iiwib24iLCJpZCIsImVycm9yIiwiYWxsVXNlcnMiLCJmcm9tIiwidG8iLCJvZmZlciIsImFuc3dlciIsInBjIiwiUGVlckNvbm5lY3Rpb24iLCJnZXRJbnN0YW5jZSIsInNpZ25hbGluZ1N0YXRlIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJsZW5ndGgiLCJjYW5kaWRhdGUiLCJzaGlmdCIsImFkZEljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsIm1lc3NhZ2UiLCJ0eXBlIiwic2V0VGltZW91dCIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsImVuZENhbGwiLCJjYXRjaCIsImRpc2Nvbm5lY3QiLCJwZWVyQ29ubmVjdGlvbiIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwiY29uZmlnIiwiaWNlU2VydmVycyIsInVybHMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImdldFNlbmRlcnMiLCJzb21lIiwic2VuZGVyIiwiYWRkVHJhY2siLCJvbnRyYWNrIiwiZXZlbnQiLCJzcmNPYmplY3QiLCJzdHJlYW1zIiwib25pY2VjYW5kaWRhdGUiLCJlbWl0Iiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJjbG9zZSIsInJlc2V0IiwiaGFuZGxlVXNlcm5hbWVDcmVhdGVkIiwibmV3VXNlcm5hbWUiLCJzZXRJdGVtIiwidXBkYXRlZFVzZXJzIiwic3RhcnRNeVZpZGVvIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ2aWRlbyIsImhhbmRsZUFjY2VwdENhbGwiLCJjcmVhdGVBbnN3ZXIiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImhhbmRsZVJlamVjdENhbGwiLCJoYW5kbGVFbmRDYWxsIiwib3RoZXJVc2VyIiwiZmluZCIsInVzZXIiLCJoYW5kbGVSZW1vdGVWaWRlb1JlZiIsInJlZiIsImhhbmRsZVN0cmVhbVJlYWR5IiwiaGFuZGxlVXNlcm5hbWVDaGFuZ2UiLCJmb3JtYXRUaW1lciIsInNlY29uZHMiLCJtaW5zIiwiTWF0aCIsImZsb29yIiwic2VjcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydENhbGwiLCJ0cmltIiwiY3JlYXRlT2ZmZXIiLCJoYW5kbGVFZGl0VXNlciIsIkN1c3RvbUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsImNsZWFyVXNlckRhdGEiLCJsb2NhdGlvbiIsInJlbG9hZCIsIm1haW4iLCJjbGFzc05hbWUiLCJjdXJyZW50VXNlciIsIm9uU3RhcnRDYWxsIiwib25FZGl0VXNlciIsIm9uVXNlcm5hbWVDcmVhdGVkIiwib25FbmRDYWxsIiwib25BY2NlcHRDYWxsIiwib25SZWplY3RDYWxsIiwib25SZW1vdGVWaWRlb1JlZiIsIm9uU3RyZWFtUmVhZHkiLCJvblVzZXJuYW1lQ2hhbmdlIiwib25DbGVhckRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});