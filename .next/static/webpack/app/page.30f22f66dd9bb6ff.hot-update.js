"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check for existing user in localStorage first\n        const savedUsername = localStorage.getItem(\"webrtc-username\");\n        if (savedUsername) {\n            console.log(\"Found existing user in localStorage:\", savedUsername);\n            setUsername(savedUsername);\n        }\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n                // If we have a saved username, automatically rejoin\n                const savedUsername = localStorage.getItem(\"webrtc-username\");\n                if (savedUsername) {\n                    var _socketRef_current1;\n                    console.log(\"Auto-rejoining with saved username:\", savedUsername);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join-user\", savedUsername);\n                }\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            const handleAnswer = async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                // Valid states for setting remote answer: have-local-offer or stable (in some rollback scenarios)\n                if (pc.signalingState === \"have-local-offer\" || pc.signalingState === \"stable\") {\n                    try {\n                        await pc.setRemoteDescription(answer);\n                        setRemoteDescriptionSet(true);\n                        console.log(\"Remote description set successfully, state:\", pc.signalingState);\n                    } catch (error) {\n                        console.error(\"Failed to set remote description:\", error);\n                        return;\n                    }\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in valid state, current state:\", pc.signalingState);\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            };\n            // Remove existing answer listener and add new one to prevent duplicates\n            socketRef.current.off(\"answer\");\n            socketRef.current.on(\"answer\", handleAnswer);\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                try {\n                    await pc.setRemoteDescription(incomingCall.offer);\n                    setRemoteDescriptionSet(true);\n                    console.log(\"Remote offer set successfully in handleAcceptCall\");\n                } catch (error) {\n                    console.error(\"Failed to set remote offer in handleAcceptCall:\", error);\n                    return;\n                }\n            } else {\n                console.error(\"Cannot set remote offer: Connection not in stable state, current state:\", pc.signalingState);\n                // Try to reset the connection and try again\n                try {\n                    PeerConnection.reset();\n                    const newPc = PeerConnection.getInstance();\n                    await newPc.setRemoteDescription(incomingCall.offer);\n                    setRemoteDescriptionSet(true);\n                    console.log(\"Remote offer set successfully after connection reset\");\n                } catch (resetError) {\n                    console.error(\"Failed to set remote offer even after reset:\", resetError);\n                    return;\n                }\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 536,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 542,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 535,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxNQUFNcUIsaUJBQWlCO1FBQ3JCLDBEQUEwRDtRQUMxRCxzREFBc0Q7UUFDdEQsTUFBTTVDLFFBQVEsSUFBSTZDLFlBQVk7UUFDOUJDLE9BQU9DLGFBQWEsQ0FBQy9DO0lBQ3ZCO0lBRUEsTUFBTWdELGdCQUFnQjtRQUNwQnRHLGFBQWF1RyxVQUFVLENBQUM7UUFDeEJ6SSxZQUFZO1FBQ1pFLFNBQVMsQ0FBQztRQUNWLElBQUlzQixVQUFVZ0IsT0FBTyxFQUFFO1lBQ3JCLDhCQUE4QjtZQUM5QmhCLFVBQVVnQixPQUFPLENBQUNPLElBQUksQ0FBQztZQUN2QnZCLFVBQVVnQixPQUFPLENBQUNpQyxVQUFVO1lBQzVCLGdDQUFnQztZQUNoQ04sV0FBVztnQkFDVG1FLE9BQU9JLFFBQVEsQ0FBQ0MsTUFBTTtZQUN4QixHQUFHO1FBQ0w7SUFDRjtJQUVBLHFCQUNFLDhEQUFDQztRQUFLQyxXQUFVOzswQkFDZCw4REFBQ2pKLDREQUFRQTtnQkFDUEssT0FBT0E7Z0JBQ1A2SSxhQUFhL0k7Z0JBQ2JnSixhQUFhZDtnQkFDYmUsWUFBWVo7Ozs7OzswQkFFZCw4REFBQ3ZJLDZEQUFTQTtnQkFDUkUsVUFBVUE7Z0JBQ1ZrSixtQkFBbUJsRDtnQkFDbkJtRCxXQUFXakM7Z0JBQ1g5RyxtQkFBbUJBO2dCQUNuQkksY0FBY0E7Z0JBQ2Q0SSxjQUFjekM7Z0JBQ2QwQyxjQUFjcEM7Z0JBQ2R2RyxrQkFBa0JBO2dCQUNsQjRJLGtCQUFrQmhDO2dCQUNsQjFHLGlCQUFpQkE7Z0JBQ2pCSSxhQUFhQTtnQkFDYnVJLGVBQWUvQjtnQkFDZnRHLFdBQVdBO2dCQUNYRSxjQUFjQTtnQkFDZG9JLGtCQUFrQi9CO2dCQUNsQmdDLGFBQWFoQjtnQkFDYm5ILGlCQUFpQkE7Ozs7Ozs7Ozs7OztBQUl6QjtHQXRpQndCdkI7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BhZ2UudHN4Pzc2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnQC9jb21wb25lbnRzL1VzZXJMaXN0JztcbmltcG9ydCBWaWRlb0NhbGwgZnJvbSAnQC9jb21wb25lbnRzL1ZpZGVvQ2FsbCc7XG5cbmludGVyZmFjZSBQZWVyQ29ubmVjdGlvbk1hbmFnZXIge1xuICBnZXRJbnN0YW5jZTogKCkgPT4gUlRDUGVlckNvbm5lY3Rpb247XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCBbdXNlcm5hbWUsIHNldFVzZXJuYW1lXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3VzZXJzLCBzZXRVc2Vyc10gPSB1c2VTdGF0ZTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pih7fSk7XG4gIGNvbnN0IFtzaG93RW5kQ2FsbEJ1dHRvbiwgc2V0U2hvd0VuZENhbGxCdXR0b25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2FsbGVyLCBzZXRDYWxsZXJdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgY29uc3QgW2luY29taW5nQ2FsbCwgc2V0SW5jb21pbmdDYWxsXSA9IHVzZVN0YXRlPHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjYWxsTm90aWZpY2F0aW9uLCBzZXRDYWxsTm90aWZpY2F0aW9uXSA9IHVzZVN0YXRlPHsgbWVzc2FnZTogc3RyaW5nOyB0eXBlOiAnc3RhcnQnIHwgJ2VuZCcgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2hvd1JlbW90ZVZpZGVvLCBzZXRTaG93UmVtb3RlVmlkZW9dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVtb3RlRGVzY3JpcHRpb25TZXQsIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0YXJ0Q2FtZXJhLCBzZXRTdGFydENhbWVyYV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYWxsVGltZXIsIHNldENhbGxUaW1lcl0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2lzQ2FsbEFjdGl2ZSwgc2V0SXNDYWxsQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Nvbm5lY3Rpb25TdGF0ZSwgc2V0Q29ubmVjdGlvblN0YXRlXSA9IHVzZVN0YXRlPCdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCc+KCdkaXNjb25uZWN0ZWQnKTtcbiAgY29uc3QgaWNlQ2FuZGlkYXRlc0J1ZmZlciA9IHVzZVJlZjxSVENJY2VDYW5kaWRhdGVJbml0W10+KFtdKTtcblxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxvY2FsU3RyZWFtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHBlZXJDb25uZWN0aW9uUmVmID0gdXNlUmVmPFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtyZW1vdGVWaWRlb0VsZW1lbnQsIHNldFJlbW90ZVZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZTxIVE1MVmlkZW9FbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVGltZXIgZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVydmFsOiBOb2RlSlMuVGltZW91dDtcbiAgICBpZiAoaXNDYWxsQWN0aXZlKSB7XG4gICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2V0Q2FsbFRpbWVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0sIFtpc0NhbGxBY3RpdmVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENoZWNrIGZvciBleGlzdGluZyB1c2VyIGluIGxvY2FsU3RvcmFnZSBmaXJzdFxuICAgIGNvbnN0IHNhdmVkVXNlcm5hbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJyk7XG4gICAgaWYgKHNhdmVkVXNlcm5hbWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBleGlzdGluZyB1c2VyIGluIGxvY2FsU3RvcmFnZTonLCBzYXZlZFVzZXJuYW1lKTtcbiAgICAgIHNldFVzZXJuYW1lKHNhdmVkVXNlcm5hbWUpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU29ja2V0LmlvIHNlcnZlciBmaXJzdFxuICAgIGZldGNoKCdodHRwOi8vMTkyLjE2OC4xMDAuMjQyOjMwMDAvYXBpL3NvY2tldCcpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQuaW8gc2VydmVyIGluaXRpYWxpemVkJyk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0byBTb2NrZXQuaW8gc2VydmVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBpbygnaHR0cDovLzE5Mi4xNjguMTAwLjI0MjozMDAwJywge1xuICAgICAgICAgIHBhdGg6ICcvYXBpL3NvY2tldCcsXG4gICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaDogZmFsc2UsXG4gICAgICAgICAgdHJhbnNwb3J0czogWydwb2xsaW5nJ10sIC8vIFVzZSBvbmx5IHBvbGxpbmcgdG8gYXZvaWQgV2ViU29ja2V0IGlzc3Vlc1xuICAgICAgICAgIHRpbWVvdXQ6IDIwMDAwLCAvLyBJbmNyZWFzZSB0aW1lb3V0IHRvIDIwIHNlY29uZHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byBzZXJ2ZXIgd2l0aCBJRDonLCBzb2NrZXRSZWYuY3VycmVudD8uaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBzYXZlZCB1c2VybmFtZSwgYXV0b21hdGljYWxseSByZWpvaW5cbiAgICAgICAgICBjb25zdCBzYXZlZFVzZXJuYW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgICAgICAgIGlmIChzYXZlZFVzZXJuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQXV0by1yZWpvaW5pbmcgd2l0aCBzYXZlZCB1c2VybmFtZTonLCBzYXZlZFVzZXJuYW1lKTtcbiAgICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luLXVzZXInLCBzYXZlZFVzZXJuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2pvaW5lZCcsIChhbGxVc2VyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgdXNlcnMgam9pbmVkOicsIGFsbFVzZXJzKTtcbiAgICAgICAgICBzZXRVc2VycyhhbGxVc2Vycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdvZmZlcicsIGFzeW5jICh7IGZyb20sIHRvLCBvZmZlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgb2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbmNvbWluZyBjYWxsIGZyb206JywgZnJvbSk7XG4gICAgICAgICAgLy8gU2hvdyBpbmNvbWluZyBjYWxsIG5vdGlmaWNhdGlvbiBpbnN0ZWFkIG9mIGF1dG8tYWNjZXB0aW5nXG4gICAgICAgICAgc2V0SW5jb21pbmdDYWxsKHsgZnJvbSwgdG8sIG9mZmVyIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBoYW5kbGVBbnN3ZXIgPSBhc3luYyAoeyBmcm9tLCB0bywgYW5zd2VyIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBhbnN3ZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIC8vIFZhbGlkIHN0YXRlcyBmb3Igc2V0dGluZyByZW1vdGUgYW5zd2VyOiBoYXZlLWxvY2FsLW9mZmVyIG9yIHN0YWJsZSAoaW4gc29tZSByb2xsYmFjayBzY2VuYXJpb3MpXG4gICAgICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSBcImhhdmUtbG9jYWwtb2ZmZXJcIiB8fCBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gXCJzdGFibGVcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZGVzY3JpcHRpb24gc2V0IHN1Y2Nlc3NmdWxseSwgc3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNldCByZW1vdGUgZGVzY3JpcHRpb246JywgZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiB2YWxpZCBzdGF0ZSwgY3VycmVudCBzdGF0ZTonLCBwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGVzXG4gICAgICAgICAgd2hpbGUgKGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCdWZmZXJlZCBJQ0UgY2FuZGlkYXRlIGFkZGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgICAgIHNldElzQ2FsbEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICBzZXRDYWxsVGltZXIoMCk7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgICAgIC8vIFNob3cgY2FsbCBhY2NlcHRlZCBub3RpZmljYXRpb24gdG8gY2FsbGVyXG4gICAgICAgICAgaWYgKGZyb20gPT09IHVzZXJuYW1lKSB7XG4gICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYCR7dG99IGFjY2VwdGVkIHlvdXIgY2FsbGAsXG4gICAgICAgICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgYW5zd2VyIGxpc3RlbmVyIGFuZCBhZGQgbmV3IG9uZSB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub2ZmKCdhbnN3ZXInKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Fuc3dlcicsIGhhbmRsZUFuc3dlcik7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgSUNFIGNhbmRpZGF0ZTonLCBjYW5kaWRhdGUpO1xuICAgICAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHBlZXIgY29ubmVjdGlvbiBpcyByZWFkeSBmb3IgSUNFIGNhbmRpZGF0ZXNcbiAgICAgICAgICBpZiAocGMucmVtb3RlRGVzY3JpcHRpb24gJiYgcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJQ0UgY2FuZGlkYXRlIGFkZGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIElDRSBjYW5kaWRhdGU6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVtb3RlIGRlc2NyaXB0aW9uIG5vdCBzZXQgeWV0LCBidWZmZXJpbmcgSUNFIGNhbmRpZGF0ZScpO1xuICAgICAgICAgICAgLy8gQnVmZmVyIHRoZSBjYW5kaWRhdGUgdG8gYWRkIGxhdGVyXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2VuZC1jYWxsJywgKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY2FsbC1lbmRlZCcsICgpID0+IHtcbiAgICAgICAgICBzZXRTaG93UmVtb3RlVmlkZW8oZmFsc2UpO1xuICAgICAgICAgIGVuZENhbGwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2NhbGwtcmVqZWN0ZWQnLCAoeyBmcm9tLCB0byB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgLy8gU2hvdyBjYWxsIHJlamVjdGVkIG5vdGlmaWNhdGlvbiB0byBjYWxsZXJcbiAgICAgICAgICBpZiAodG8gPT09IHVzZXJuYW1lKSB7XG4gICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYCR7ZnJvbX0gcmVqZWN0ZWQgeW91ciBjYWxsYCxcbiAgICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VzZXJuYW1lLXRha2VuJywgKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIHRha2VuOicsIG1lc3NhZ2UpO1xuICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6ICdlbmQnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvY2tldC5pbyBzZXJ2ZXI6JywgZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgUGVlckNvbm5lY3Rpb246IFBlZXJDb25uZWN0aW9uTWFuYWdlciA9ICgoKSA9PiB7XG4gICAgbGV0IHBlZXJDb25uZWN0aW9uOiBSVENQZWVyQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3QgY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGljZVNlcnZlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1cmxzOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMidcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgICBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWcpO1xuXG4gICAgICAvLyBDbGVhciBJQ0UgY2FuZGlkYXRlcyBidWZmZXIgd2hlbiBjcmVhdGluZyBuZXcgY29ubmVjdGlvblxuICAgICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50ID0gW107XG5cbiAgICAgIGlmIChsb2NhbFN0cmVhbVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgc2VuZGVyIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHRyYWNrXG4gICAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbiEuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbiEuYWRkVHJhY2sodHJhY2ssIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChyZW1vdGVWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICByZW1vdGVWaWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gZXZlbnQuc3RyZWFtc1swXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdpY2VjYW5kaWRhdGUnLCBldmVudC5jYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkOicsIHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0SW5zdGFuY2U6ICgpID0+IHtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIGZvciBlYWNoIGNhbGxcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBwZWVyQ29ubmVjdGlvbiA9IGNyZWF0ZVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbjtcbiAgICAgIH0sXG4gICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBJQ0UgY2FuZGlkYXRlcyBidWZmZXIgb24gcmVzZXRcbiAgICAgICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50ID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBjb25zdCBoYW5kbGVVc2VybmFtZUNyZWF0ZWQgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyB1c2VyOicsIG5ld1VzZXJuYW1lKTtcbiAgICBzZXRVc2VybmFtZShuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIEFkZCBjdXJyZW50IHVzZXIgdG8gbG9jYWwgbGlzdCBpbW1lZGlhdGVseSBmb3IgYmV0dGVyIFVYXG4gICAgc2V0VXNlcnMocHJldiA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkVXNlcnMgPSB7IC4uLnByZXYsIFtuZXdVc2VybmFtZV06IG5ld1VzZXJuYW1lIH07XG4gICAgICBjb25zb2xlLmxvZygnTG9jYWwgdXNlcnMgdXBkYXRlZDonLCB1cGRhdGVkVXNlcnMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWRVc2VycztcbiAgICB9KTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB0byBzeW5jIHdpdGggb3RoZXIgZGV2aWNlc1xuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ0VtaXR0ZWQgam9pbi11c2VyIGV2ZW50IGZvcjonLCBuZXdVc2VybmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0YXJ0TXlWaWRlbyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSwgdmlkZW86IHRydWUgfSk7XG4gICAgICBjb25zb2xlLmxvZyh7IHN0cmVhbSB9KTtcbiAgICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBtZWRpYSBkZXZpY2VzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZW5kQ2FsbCA9ICgpID0+IHtcbiAgICBQZWVyQ29ubmVjdGlvbi5yZXNldCgpO1xuICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKGZhbHNlKTtcbiAgICBzZXRTaG93UmVtb3RlVmlkZW8oZmFsc2UpO1xuICAgIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0KGZhbHNlKTtcbiAgICBzZXRTdGFydENhbWVyYShmYWxzZSk7XG4gICAgc2V0SXNDYWxsQWN0aXZlKGZhbHNlKTtcbiAgICBzZXRDYWxsVGltZXIoMCk7XG4gICAgc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVBY2NlcHRDYWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaW5jb21pbmdDYWxsKSByZXR1cm47XG5cbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBhY2NlcHRpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG5cbiAgICAvLyBXYWl0IGEgYml0IGZvciBjYW1lcmEgdG8gc3RhcnRcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihpbmNvbWluZ0NhbGwub2ZmZXIpO1xuICAgICAgICAgIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0KHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgb2ZmZXIgc2V0IHN1Y2Nlc3NmdWxseSBpbiBoYW5kbGVBY2NlcHRDYWxsJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNldCByZW1vdGUgb2ZmZXIgaW4gaGFuZGxlQWNjZXB0Q2FsbDonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3Qgc2V0IHJlbW90ZSBvZmZlcjogQ29ubmVjdGlvbiBub3QgaW4gc3RhYmxlIHN0YXRlLCBjdXJyZW50IHN0YXRlOicsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgLy8gVHJ5IHRvIHJlc2V0IHRoZSBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBQZWVyQ29ubmVjdGlvbi5yZXNldCgpO1xuICAgICAgICAgIGNvbnN0IG5ld1BjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBhd2FpdCBuZXdQYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihpbmNvbWluZ0NhbGwub2ZmZXIpO1xuICAgICAgICAgIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0KHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgb2ZmZXIgc2V0IHN1Y2Nlc3NmdWxseSBhZnRlciBjb25uZWN0aW9uIHJlc2V0Jyk7XG4gICAgICAgIH0gY2F0Y2ggKHJlc2V0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHJlbW90ZSBvZmZlciBldmVuIGFmdGVyIHJlc2V0OicsIHJlc2V0RXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgIHdoaWxlIChpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5IGluIGhhbmRsZUFjY2VwdENhbGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGUgaW4gaGFuZGxlQWNjZXB0Q2FsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBhd2FpdCBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cbiAgICAgIC8vIEFkZCBsb2NhbCBzdHJlYW0gdG8gcGVlciBjb25uZWN0aW9uXG4gICAgICBpZiAobG9jYWxTdHJlYW1SZWYuY3VycmVudCkge1xuICAgICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbmRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIGlmICghcGMuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdhbnN3ZXInLCB7XG4gICAgICAgIGZyb206IGluY29taW5nQ2FsbC50byxcbiAgICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tLFxuICAgICAgICBhbnN3ZXI6IHBjLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgIH0pO1xuXG4gICAgICBzZXRDYWxsZXIoW2luY29taW5nQ2FsbC5mcm9tLCBpbmNvbWluZ0NhbGwudG9dKTtcbiAgICAgIHNldEluY29taW5nQ2FsbChudWxsKTtcbiAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgLy8gU2hvdyBjYWxsIHN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYWxsIHN0YXJ0ZWQgd2l0aCAke2luY29taW5nQ2FsbC5mcm9tfWAsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIG5vdGlmaWNhdGlvbiBhZnRlciAzIHNlY29uZHNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVqZWN0Q2FsbCA9ICgpID0+IHtcbiAgICBpZiAoIWluY29taW5nQ2FsbCkgcmV0dXJuO1xuXG4gICAgLy8gTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCBjYWxsIHdhcyByZWplY3RlZFxuICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdjYWxsLXJlamVjdGVkJywge1xuICAgICAgZnJvbTogaW5jb21pbmdDYWxsLnRvLFxuICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tXG4gICAgfSk7XG5cbiAgICBzZXRJbmNvbWluZ0NhbGwobnVsbCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRW5kQ2FsbCA9ICgpID0+IHtcbiAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnY2FsbC1lbmRlZCcsIGNhbGxlcik7XG5cbiAgICAvLyBTaG93IGNhbGwgZW5kIG5vdGlmaWNhdGlvblxuICAgIGNvbnN0IG90aGVyVXNlciA9IGNhbGxlci5maW5kKHVzZXIgPT4gdXNlciAhPT0gdXNlcm5hbWUpO1xuICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgbWVzc2FnZTogYENhbGwgZW5kZWQgd2l0aCAke290aGVyVXNlcn1gLFxuICAgICAgdHlwZTogJ2VuZCdcbiAgICB9KTtcblxuICAgIC8vIEhpZGUgbm90aWZpY2F0aW9uIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVSZW1vdGVWaWRlb1JlZiA9IChyZWY6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVtb3RlVmlkZW9FbGVtZW50KHJlZik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU3RyZWFtUmVhZHkgPSAoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVXNlcm5hbWVDaGFuZ2UgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB3aXRoIG5ldyB1c2VybmFtZVxuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIGNoYW5nZWQgdG86JywgbmV3VXNlcm5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmb3JtYXRUaW1lciA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBzZWNvbmRzICUgNjA7XG4gICAgcmV0dXJuIGAke21pbnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRDYWxsID0gYXN5bmMgKHVzZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKHsgdXNlciB9KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgaWYgKCF1c2VybmFtZSB8fCB1c2VybmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBjcmVhdGUgYSB1c2VybmFtZSBmaXJzdCcsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpLCAzMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0YXJnZXQgdXNlciBleGlzdHNcbiAgICBpZiAoIXVzZXJzW3VzZXJdKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBUYXJnZXQgdXNlciBub3QgZm91bmQnKTtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiBgVXNlciAke3VzZXJ9IGlzIG5vdCBhdmFpbGFibGVgLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKSwgMzAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXRlIHRvIGNvbm5lY3RpbmdcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICBcbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBtYWtpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG4gICAgXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FtZXJhIHRvIHN0YXJ0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICBjb25zb2xlLmxvZyh7IG9mZmVyIH0pO1xuICAgICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnb2ZmZXInLCB7IGZyb206IHVzZXJuYW1lLCB0bzogdXNlciwgb2ZmZXI6IHBjLmxvY2FsRGVzY3JpcHRpb24gfSk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRWRpdFVzZXIgPSAoKSA9PiB7XG4gICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGVkaXQgbW9kYWwgaW4gVmlkZW9DYWxsIGNvbXBvbmVudFxuICAgIC8vIFdlJ2xsIHVzZSBhIHN0YXRlIHRvIGNvbW11bmljYXRlIGJldHdlZW4gY29tcG9uZW50c1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdvcGVuRWRpdE1vZGFsJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyVXNlckRhdGEgPSAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgIHNldFVzZXJuYW1lKCcnKTtcbiAgICBzZXRVc2Vycyh7fSk7XG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDbGVhciBhbGwgdXNlcnMgZnJvbSBzZXJ2ZXJcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2NsZWFyLWFsbC11c2VycycpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gUmVjb25uZWN0IGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJoLXNjcmVlbiBmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93XCI+XG4gICAgICA8VXNlckxpc3RcbiAgICAgICAgdXNlcnM9e3VzZXJzfVxuICAgICAgICBjdXJyZW50VXNlcj17dXNlcm5hbWV9XG4gICAgICAgIG9uU3RhcnRDYWxsPXtzdGFydENhbGx9XG4gICAgICAgIG9uRWRpdFVzZXI9e2hhbmRsZUVkaXRVc2VyfVxuICAgICAgLz5cbiAgICAgIDxWaWRlb0NhbGxcbiAgICAgICAgdXNlcm5hbWU9e3VzZXJuYW1lfVxuICAgICAgICBvblVzZXJuYW1lQ3JlYXRlZD17aGFuZGxlVXNlcm5hbWVDcmVhdGVkfVxuICAgICAgICBvbkVuZENhbGw9e2hhbmRsZUVuZENhbGx9XG4gICAgICAgIHNob3dFbmRDYWxsQnV0dG9uPXtzaG93RW5kQ2FsbEJ1dHRvbn1cbiAgICAgICAgaW5jb21pbmdDYWxsPXtpbmNvbWluZ0NhbGx9XG4gICAgICAgIG9uQWNjZXB0Q2FsbD17aGFuZGxlQWNjZXB0Q2FsbH1cbiAgICAgICAgb25SZWplY3RDYWxsPXtoYW5kbGVSZWplY3RDYWxsfVxuICAgICAgICBjYWxsTm90aWZpY2F0aW9uPXtjYWxsTm90aWZpY2F0aW9ufVxuICAgICAgICBvblJlbW90ZVZpZGVvUmVmPXtoYW5kbGVSZW1vdGVWaWRlb1JlZn1cbiAgICAgICAgc2hvd1JlbW90ZVZpZGVvPXtzaG93UmVtb3RlVmlkZW99XG4gICAgICAgIHN0YXJ0Q2FtZXJhPXtzdGFydENhbWVyYX1cbiAgICAgICAgb25TdHJlYW1SZWFkeT17aGFuZGxlU3RyZWFtUmVhZHl9XG4gICAgICAgIGNhbGxUaW1lcj17Y2FsbFRpbWVyfVxuICAgICAgICBpc0NhbGxBY3RpdmU9e2lzQ2FsbEFjdGl2ZX1cbiAgICAgICAgb25Vc2VybmFtZUNoYW5nZT17aGFuZGxlVXNlcm5hbWVDaGFuZ2V9XG4gICAgICAgIG9uQ2xlYXJEYXRhPXtjbGVhclVzZXJEYXRhfVxuICAgICAgICBjb25uZWN0aW9uU3RhdGU9e2Nvbm5lY3Rpb25TdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9tYWluPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaW8iLCJVc2VyTGlzdCIsIlZpZGVvQ2FsbCIsIkhvbWUiLCJ1c2VybmFtZSIsInNldFVzZXJuYW1lIiwidXNlcnMiLCJzZXRVc2VycyIsInNob3dFbmRDYWxsQnV0dG9uIiwic2V0U2hvd0VuZENhbGxCdXR0b24iLCJjYWxsZXIiLCJzZXRDYWxsZXIiLCJpbmNvbWluZ0NhbGwiLCJzZXRJbmNvbWluZ0NhbGwiLCJjYWxsTm90aWZpY2F0aW9uIiwic2V0Q2FsbE5vdGlmaWNhdGlvbiIsInNob3dSZW1vdGVWaWRlbyIsInNldFNob3dSZW1vdGVWaWRlbyIsInJlbW90ZURlc2NyaXB0aW9uU2V0Iiwic2V0UmVtb3RlRGVzY3JpcHRpb25TZXQiLCJzdGFydENhbWVyYSIsInNldFN0YXJ0Q2FtZXJhIiwiY2FsbFRpbWVyIiwic2V0Q2FsbFRpbWVyIiwiaXNDYWxsQWN0aXZlIiwic2V0SXNDYWxsQWN0aXZlIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwiaWNlQ2FuZGlkYXRlc0J1ZmZlciIsInNvY2tldFJlZiIsImxvY2FsU3RyZWFtUmVmIiwicGVlckNvbm5lY3Rpb25SZWYiLCJyZW1vdGVWaWRlb0VsZW1lbnQiLCJzZXRSZW1vdGVWaWRlb0VsZW1lbnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHJldiIsImNsZWFySW50ZXJ2YWwiLCJzYXZlZFVzZXJuYW1lIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvbnNvbGUiLCJsb2ciLCJmZXRjaCIsInRoZW4iLCJjdXJyZW50IiwicGF0aCIsImFkZFRyYWlsaW5nU2xhc2giLCJ0cmFuc3BvcnRzIiwidGltZW91dCIsIm9uIiwiaWQiLCJlbWl0IiwiZXJyb3IiLCJhbGxVc2VycyIsImZyb20iLCJ0byIsIm9mZmVyIiwiaGFuZGxlQW5zd2VyIiwiYW5zd2VyIiwicGMiLCJQZWVyQ29ubmVjdGlvbiIsImdldEluc3RhbmNlIiwic2lnbmFsaW5nU3RhdGUiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImxlbmd0aCIsImNhbmRpZGF0ZSIsInNoaWZ0IiwiYWRkSWNlQ2FuZGlkYXRlIiwiUlRDSWNlQ2FuZGlkYXRlIiwibWVzc2FnZSIsInR5cGUiLCJzZXRUaW1lb3V0Iiwib2ZmIiwicmVtb3RlRGVzY3JpcHRpb24iLCJwdXNoIiwiZW5kQ2FsbCIsImNhdGNoIiwiZGlzY29ubmVjdCIsInBlZXJDb25uZWN0aW9uIiwiY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJjb25maWciLCJpY2VTZXJ2ZXJzIiwidXJscyIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInRyYWNrIiwiZ2V0U2VuZGVycyIsInNvbWUiLCJzZW5kZXIiLCJhZGRUcmFjayIsIm9udHJhY2siLCJldmVudCIsInNyY09iamVjdCIsInN0cmVhbXMiLCJvbmljZWNhbmRpZGF0ZSIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiY2xvc2UiLCJyZXNldCIsImhhbmRsZVVzZXJuYW1lQ3JlYXRlZCIsIm5ld1VzZXJuYW1lIiwic2V0SXRlbSIsInVwZGF0ZWRVc2VycyIsInN0YXJ0TXlWaWRlbyIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwidmlkZW8iLCJoYW5kbGVBY2NlcHRDYWxsIiwibmV3UGMiLCJyZXNldEVycm9yIiwiY3JlYXRlQW5zd2VyIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsImxvY2FsRGVzY3JpcHRpb24iLCJoYW5kbGVSZWplY3RDYWxsIiwiaGFuZGxlRW5kQ2FsbCIsIm90aGVyVXNlciIsImZpbmQiLCJ1c2VyIiwiaGFuZGxlUmVtb3RlVmlkZW9SZWYiLCJyZWYiLCJoYW5kbGVTdHJlYW1SZWFkeSIsImhhbmRsZVVzZXJuYW1lQ2hhbmdlIiwiZm9ybWF0VGltZXIiLCJzZWNvbmRzIiwibWlucyIsIk1hdGgiLCJmbG9vciIsInNlY3MiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic3RhcnRDYWxsIiwidHJpbSIsImNyZWF0ZU9mZmVyIiwiaGFuZGxlRWRpdFVzZXIiLCJDdXN0b21FdmVudCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJjbGVhclVzZXJEYXRhIiwicmVtb3ZlSXRlbSIsImxvY2F0aW9uIiwicmVsb2FkIiwibWFpbiIsImNsYXNzTmFtZSIsImN1cnJlbnRVc2VyIiwib25TdGFydENhbGwiLCJvbkVkaXRVc2VyIiwib25Vc2VybmFtZUNyZWF0ZWQiLCJvbkVuZENhbGwiLCJvbkFjY2VwdENhbGwiLCJvblJlamVjdENhbGwiLCJvblJlbW90ZVZpZGVvUmVmIiwib25TdHJlYW1SZWFkeSIsIm9uVXNlcm5hbWVDaGFuZ2UiLCJvbkNsZWFyRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});