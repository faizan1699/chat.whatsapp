"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_VideoCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VideoCall */ \"(app-pages-browser)/./components/VideoCall.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Home() {\n    _s();\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [showEndCallButton, setShowEndCallButton] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [caller, setCaller] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [incomingCall, setIncomingCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [callNotification, setCallNotification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showRemoteVideo, setShowRemoteVideo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [remoteDescriptionSet, setRemoteDescriptionSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startCamera, setStartCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [callTimer, setCallTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isCallActive, setIsCallActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const iceCandidatesBuffer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const localStreamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const peerConnectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [remoteVideoElement, setRemoteVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let interval;\n        if (isCallActive) {\n            interval = setInterval(()=>{\n                setCallTimer((prev)=>prev + 1);\n            }, 1000);\n        }\n        return ()=>{\n            if (interval) clearInterval(interval);\n        };\n    }, [\n        isCallActive\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Clear any old data and start fresh\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        // Initialize Socket.io server first\n        fetch(\"http://192.168.100.242:3000/api/socket\").then(()=>{\n            console.log(\"Socket.io server initialized\");\n            // Connect to Socket.io server with proper configuration\n            socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(\"http://192.168.100.242:3000\", {\n                path: \"/api/socket\",\n                addTrailingSlash: false,\n                transports: [\n                    \"polling\"\n                ],\n                timeout: 20000\n            });\n            socketRef.current.on(\"connect\", ()=>{\n                var _socketRef_current;\n                console.log(\"Connected to server with ID:\", (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.id);\n            });\n            socketRef.current.on(\"connect_error\", (error)=>{\n                console.error(\"Connection error:\", error);\n            });\n            socketRef.current.on(\"disconnect\", ()=>{\n                console.log(\"Disconnected from server\");\n            });\n            socketRef.current.on(\"joined\", (allUsers)=>{\n                console.log(\"All users joined:\", allUsers);\n                setUsers(allUsers);\n            });\n            socketRef.current.on(\"offer\", async (param)=>{\n                let { from, to, offer } = param;\n                console.log(\"Incoming call from:\", from);\n                // Show incoming call notification instead of auto-accepting\n                setIncomingCall({\n                    from,\n                    to,\n                    offer\n                });\n            });\n            const handleAnswer = async (param)=>{\n                let { from, to, answer } = param;\n                const pc = PeerConnection.getInstance();\n                // Check connection state before setting remote description\n                // Valid states for setting remote answer: have-local-offer or stable (in some rollback scenarios)\n                if (pc.signalingState === \"have-local-offer\" || pc.signalingState === \"stable\") {\n                    try {\n                        await pc.setRemoteDescription(answer);\n                        setRemoteDescriptionSet(true);\n                        console.log(\"Remote description set successfully, state:\", pc.signalingState);\n                    } catch (error) {\n                        console.error(\"Failed to set remote description:\", error);\n                        return;\n                    }\n                } else {\n                    console.error(\"Cannot set remote description: Connection not in valid state, current state:\", pc.signalingState);\n                    return;\n                }\n                // Add buffered ICE candidates\n                while(iceCandidatesBuffer.current.length > 0){\n                    try {\n                        const candidate = iceCandidatesBuffer.current.shift();\n                        if (candidate) {\n                            await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                            console.log(\"Buffered ICE candidate added successfully\");\n                        }\n                    } catch (error) {\n                        console.error(\"Error adding buffered ICE candidate:\", error);\n                    }\n                }\n                setShowEndCallButton(true);\n                setShowRemoteVideo(true);\n                setIsCallActive(true);\n                setCallTimer(0);\n                setConnectionState(\"connected\");\n                // Show call accepted notification to caller\n                if (from === username) {\n                    setCallNotification({\n                        message: \"\".concat(to, \" accepted your call\"),\n                        type: \"start\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            };\n            // Remove existing answer listener and add new one to prevent duplicates\n            socketRef.current.off(\"answer\");\n            socketRef.current.on(\"answer\", handleAnswer);\n            socketRef.current.on(\"icecandidate\", async (candidate)=>{\n                console.log(\"Received ICE candidate:\", candidate);\n                const pc = PeerConnection.getInstance();\n                // Check if peer connection is ready for ICE candidates\n                if (pc.remoteDescription && pc.remoteDescription.type) {\n                    try {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"ICE candidate added successfully\");\n                    } catch (error) {\n                        console.error(\"Error adding ICE candidate:\", error);\n                    }\n                } else {\n                    console.log(\"Remote description not set yet, buffering ICE candidate\");\n                    // Buffer the candidate to add later\n                    iceCandidatesBuffer.current.push(candidate);\n                }\n            });\n            socketRef.current.on(\"end-call\", (param)=>{\n                let { from, to } = param;\n                setShowEndCallButton(true);\n            });\n            socketRef.current.on(\"call-ended\", ()=>{\n                setShowRemoteVideo(false);\n                endCall();\n            });\n            socketRef.current.on(\"call-rejected\", (param)=>{\n                let { from, to } = param;\n                // Show call rejected notification to caller\n                if (to === username) {\n                    setCallNotification({\n                        message: \"\".concat(from, \" rejected your call\"),\n                        type: \"end\"\n                    });\n                    setTimeout(()=>{\n                        setCallNotification(null);\n                    }, 3000);\n                }\n            });\n            socketRef.current.on(\"username-taken\", (param)=>{\n                let { message } = param;\n                console.log(\"Username taken:\", message);\n                setCallNotification({\n                    message: message,\n                    type: \"end\"\n                });\n                setTimeout(()=>{\n                    setCallNotification(null);\n                }, 3000);\n            });\n        }).catch((error)=>{\n            console.error(\"Failed to initialize Socket.io server:\", error);\n        });\n        return ()=>{\n            var _socketRef_current;\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.disconnect();\n        };\n    }, []);\n    const PeerConnection = (()=>{\n        let peerConnection = null;\n        const createPeerConnection = ()=>{\n            const config = {\n                iceServers: [\n                    {\n                        urls: \"stun:stun.l.google.com:19302\"\n                    }\n                ]\n            };\n            peerConnection = new RTCPeerConnection(config);\n            // Clear ICE candidates buffer when creating new connection\n            iceCandidatesBuffer.current = [];\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!peerConnection.getSenders().some((sender)=>sender.track === track)) {\n                        peerConnection.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            peerConnection.ontrack = function(event) {\n                if (remoteVideoElement) {\n                    remoteVideoElement.srcObject = event.streams[0];\n                }\n            };\n            peerConnection.onicecandidate = function(event) {\n                if (event.candidate) {\n                    var _socketRef_current;\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"icecandidate\", event.candidate);\n                }\n            };\n            peerConnection.onconnectionstatechange = function(event) {\n                console.log(\"Connection state changed:\", peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState);\n                if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"connected\") {\n                    setConnectionState(\"connected\");\n                } else if ((peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"disconnected\" || (peerConnection === null || peerConnection === void 0 ? void 0 : peerConnection.connectionState) === \"failed\") {\n                    setConnectionState(\"disconnected\");\n                }\n            };\n            return peerConnection;\n        };\n        return {\n            getInstance: ()=>{\n                // Always create a new connection for each call\n                if (peerConnection) {\n                    peerConnection.close();\n                }\n                peerConnection = createPeerConnection();\n                return peerConnection;\n            },\n            reset: ()=>{\n                if (peerConnection) {\n                    peerConnection.close();\n                    peerConnection = null;\n                }\n                // Clear ICE candidates buffer on reset\n                iceCandidatesBuffer.current = [];\n            }\n        };\n    })();\n    const handleUsernameCreated = (newUsername)=>{\n        console.log(\"Creating user:\", newUsername);\n        setUsername(newUsername);\n        // Save to localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Add current user to local list immediately for better UX\n        setUsers((prev)=>{\n            const updatedUsers = {\n                ...prev,\n                [newUsername]: newUsername\n            };\n            console.log(\"Local users updated:\", updatedUsers);\n            return updatedUsers;\n        });\n        // Emit to server to sync with other devices\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Emitted join-user event for:\", newUsername);\n        }\n    };\n    const startMyVideo = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            });\n            console.log({\n                stream\n            });\n            localStreamRef.current = stream;\n        } catch (error) {\n            console.error(\"Error accessing media devices:\", error);\n        }\n    };\n    const endCall = ()=>{\n        PeerConnection.reset();\n        setShowEndCallButton(false);\n        setShowRemoteVideo(false);\n        setRemoteDescriptionSet(false);\n        setStartCamera(false);\n        setIsCallActive(false);\n        setCallTimer(0);\n        setConnectionState(\"disconnected\");\n        iceCandidatesBuffer.current = [];\n    };\n    const handleAcceptCall = async ()=>{\n        if (!incomingCall) return;\n        // Start camera when accepting a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            // Check connection state before setting remote description\n            if (pc.signalingState === \"stable\") {\n                await pc.setRemoteDescription(incomingCall.offer);\n                setRemoteDescriptionSet(true);\n            } else {\n                console.error(\"Cannot set remote description: Connection not in stable state, current state:\", pc.signalingState);\n                return;\n            }\n            // Add buffered ICE candidates\n            while(iceCandidatesBuffer.current.length > 0){\n                try {\n                    const candidate = iceCandidatesBuffer.current.shift();\n                    if (candidate) {\n                        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n                        console.log(\"Buffered ICE candidate added successfully in handleAcceptCall\");\n                    }\n                } catch (error) {\n                    console.error(\"Error adding buffered ICE candidate in handleAcceptCall:\", error);\n                }\n            }\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            // Add local stream to peer connection\n            if (localStreamRef.current) {\n                localStreamRef.current.getTracks().forEach((track)=>{\n                    // Check if sender already exists for this track\n                    if (!pc.getSenders().some((sender)=>sender.track === track)) {\n                        pc.addTrack(track, localStreamRef.current);\n                    }\n                });\n            }\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"answer\", {\n                from: incomingCall.to,\n                to: incomingCall.from,\n                answer: pc.localDescription\n            });\n            setCaller([\n                incomingCall.from,\n                incomingCall.to\n            ]);\n            setIncomingCall(null);\n            setShowEndCallButton(true);\n            setShowRemoteVideo(true);\n            setIsCallActive(true);\n            setCallTimer(0);\n            setConnectionState(\"connected\");\n            // Show call start notification\n            setCallNotification({\n                message: \"Call started with \".concat(incomingCall.from),\n                type: \"start\"\n            });\n            // Hide notification after 3 seconds\n            setTimeout(()=>{\n                setCallNotification(null);\n            }, 3000);\n        }, 1000);\n    };\n    const handleRejectCall = ()=>{\n        var // Notify the caller that call was rejected\n        _socketRef_current;\n        if (!incomingCall) return;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-rejected\", {\n            from: incomingCall.to,\n            to: incomingCall.from\n        });\n        setIncomingCall(null);\n    };\n    const handleEndCall = ()=>{\n        var _socketRef_current;\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"call-ended\", caller);\n        // Show call end notification\n        const otherUser = caller.find((user)=>user !== username);\n        setCallNotification({\n            message: \"Call ended with \".concat(otherUser),\n            type: \"end\"\n        });\n        // Hide notification after 3 seconds\n        setTimeout(()=>{\n            setCallNotification(null);\n        }, 3000);\n    };\n    const handleRemoteVideoRef = (ref)=>{\n        setRemoteVideoElement(ref);\n    };\n    const handleStreamReady = (stream)=>{\n        localStreamRef.current = stream;\n    };\n    const handleUsernameChange = (newUsername)=>{\n        // Update localStorage\n        localStorage.setItem(\"webrtc-username\", newUsername);\n        // Update state\n        setUsername(newUsername);\n        // Emit to server with new username\n        if (socketRef.current) {\n            socketRef.current.emit(\"join-user\", newUsername);\n            console.log(\"Username changed to:\", newUsername);\n        }\n    };\n    const formatTimer = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n    };\n    const startCall = async (user)=>{\n        console.log({\n            user\n        });\n        // Validate that current user is authenticated\n        if (!username || username.trim() === \"\") {\n            console.error(\"Cannot make call: User not authenticated\");\n            setCallNotification({\n                message: \"Please create a username first\",\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Validate that target user exists\n        if (!users[user]) {\n            console.error(\"Cannot make call: Target user not found\");\n            setCallNotification({\n                message: \"User \".concat(user, \" is not available\"),\n                type: \"start\"\n            });\n            setTimeout(()=>setCallNotification(null), 3000);\n            return;\n        }\n        // Set connection state to connecting\n        setConnectionState(\"connecting\");\n        // Start camera when making a call\n        setStartCamera(true);\n        // Wait a bit for camera to start\n        setTimeout(async ()=>{\n            var _socketRef_current;\n            const pc = PeerConnection.getInstance();\n            const offer = await pc.createOffer();\n            console.log({\n                offer\n            });\n            await pc.setLocalDescription(offer);\n            (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"offer\", {\n                from: username,\n                to: user,\n                offer: pc.localDescription\n            });\n        }, 1000);\n    };\n    const handleEditUser = ()=>{\n        // This will trigger the edit modal in VideoCall component\n        // We'll use a state to communicate between components\n        const event = new CustomEvent(\"openEditModal\");\n        window.dispatchEvent(event);\n    };\n    const clearUserData = ()=>{\n        localStorage.removeItem(\"webrtc-username\");\n        setUsername(\"\");\n        setUsers({});\n        if (socketRef.current) {\n            // Clear all users from server\n            socketRef.current.emit(\"clear-all-users\");\n            socketRef.current.disconnect();\n            // Reconnect after a short delay\n            setTimeout(()=>{\n                window.location.reload();\n            }, 1000);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-screen flex flex-col md:flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                users: users,\n                currentUser: username,\n                onStartCall: startCall,\n                onEditUser: handleEditUser\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 511,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                username: username,\n                onUsernameCreated: handleUsernameCreated,\n                onEndCall: handleEndCall,\n                showEndCallButton: showEndCallButton,\n                incomingCall: incomingCall,\n                onAcceptCall: handleAcceptCall,\n                onRejectCall: handleRejectCall,\n                callNotification: callNotification,\n                onRemoteVideoRef: handleRemoteVideoRef,\n                showRemoteVideo: showRemoteVideo,\n                startCamera: startCamera,\n                onStreamReady: handleStreamReady,\n                callTimer: callTimer,\n                isCallActive: isCallActive,\n                onUsernameChange: handleUsernameChange,\n                onClearData: clearUserData,\n                connectionState: connectionState\n            }, void 0, false, {\n                fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n                lineNumber: 517,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/faizan169/work/web rtc/nextjs-webrtc-app/app/page.tsx\",\n        lineNumber: 510,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"gaX/tj2jxhRjjjAfps8lxqQEQJA=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bkM7Z0JBQ2RwRyxrQkFBa0JBO2dCQUNsQndJLGtCQUFrQi9CO2dCQUNsQnZHLGlCQUFpQkE7Z0JBQ2pCSSxhQUFhQTtnQkFDYm1JLGVBQWU5QjtnQkFDZm5HLFdBQVdBO2dCQUNYRSxjQUFjQTtnQkFDZGdJLGtCQUFrQjlCO2dCQUNsQitCLGFBQWFmO2dCQUNiaEgsaUJBQWlCQTs7Ozs7Ozs7Ozs7O0FBSXpCO0dBN2dCd0J2QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBVc2VyTGlzdCBmcm9tICdAL2NvbXBvbmVudHMvVXNlckxpc3QnO1xuaW1wb3J0IFZpZGVvQ2FsbCBmcm9tICdAL2NvbXBvbmVudHMvVmlkZW9DYWxsJztcblxuaW50ZXJmYWNlIFBlZXJDb25uZWN0aW9uTWFuYWdlciB7XG4gIGdldEluc3RhbmNlOiAoKSA9PiBSVENQZWVyQ29ubmVjdGlvbjtcbiAgcmVzZXQ6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFt1c2VybmFtZSwgc2V0VXNlcm5hbWVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+KHt9KTtcbiAgY29uc3QgW3Nob3dFbmRDYWxsQnV0dG9uLCBzZXRTaG93RW5kQ2FsbEJ1dHRvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYWxsZXIsIHNldENhbGxlcl0gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbaW5jb21pbmdDYWxsLCBzZXRJbmNvbWluZ0NhbGxdID0gdXNlU3RhdGU8eyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NhbGxOb3RpZmljYXRpb24sIHNldENhbGxOb3RpZmljYXRpb25dID0gdXNlU3RhdGU8eyBtZXNzYWdlOiBzdHJpbmc7IHR5cGU6ICdzdGFydCcgfCAnZW5kJyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93UmVtb3RlVmlkZW8sIHNldFNob3dSZW1vdGVWaWRlb10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZW1vdGVEZXNjcmlwdGlvblNldCwgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhcnRDYW1lcmEsIHNldFN0YXJ0Q2FtZXJhXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhbGxUaW1lciwgc2V0Q2FsbFRpbWVyXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbaXNDYWxsQWN0aXZlLCBzZXRJc0NhbGxBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8J2Nvbm5lY3RpbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJz4oJ2Rpc2Nvbm5lY3RlZCcpO1xuICBjb25zdCBpY2VDYW5kaWRhdGVzQnVmZmVyID0gdXNlUmVmPFJUQ0ljZUNhbmRpZGF0ZUluaXRbXT4oW10pO1xuXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9jYWxTdHJlYW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgcGVlckNvbm5lY3Rpb25SZWYgPSB1c2VSZWY8UlRDUGVlckNvbm5lY3Rpb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3JlbW90ZVZpZGVvRWxlbWVudCwgc2V0UmVtb3RlVmlkZW9FbGVtZW50XSA9IHVzZVN0YXRlPEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICAvLyBUaW1lciBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0O1xuICAgIGlmIChpc0NhbGxBY3RpdmUpIHtcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsVGltZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpbnRlcnZhbCkgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgfTtcbiAgfSwgW2lzQ2FsbEFjdGl2ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgYW55IG9sZCBkYXRhIGFuZCBzdGFydCBmcmVzaFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3ZWJydGMtdXNlcm5hbWUnKTtcbiAgICBzZXRVc2VybmFtZSgnJyk7XG4gICAgc2V0VXNlcnMoe30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBTb2NrZXQuaW8gc2VydmVyIGZpcnN0XG4gICAgZmV0Y2goJ2h0dHA6Ly8xOTIuMTY4LjEwMC4yNDI6MzAwMC9hcGkvc29ja2V0JylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NvY2tldC5pbyBzZXJ2ZXIgaW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAvLyBDb25uZWN0IHRvIFNvY2tldC5pbyBzZXJ2ZXIgd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKCdodHRwOi8vMTkyLjE2OC4xMDAuMjQyOjMwMDAnLCB7XG4gICAgICAgICAgcGF0aDogJy9hcGkvc29ja2V0JyxcbiAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoOiBmYWxzZSxcbiAgICAgICAgICB0cmFuc3BvcnRzOiBbJ3BvbGxpbmcnXSwgLy8gVXNlIG9ubHkgcG9sbGluZyB0byBhdm9pZCBXZWJTb2NrZXQgaXNzdWVzXG4gICAgICAgICAgdGltZW91dDogMjAwMDAsIC8vIEluY3JlYXNlIHRpbWVvdXQgdG8gMjAgc2Vjb25kc1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHNlcnZlciB3aXRoIElEOicsIHNvY2tldFJlZi5jdXJyZW50Py5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2pvaW5lZCcsIChhbGxVc2VyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgdXNlcnMgam9pbmVkOicsIGFsbFVzZXJzKTtcbiAgICAgICAgICBzZXRVc2VycyhhbGxVc2Vycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdvZmZlcicsIGFzeW5jICh7IGZyb20sIHRvLCBvZmZlciB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgb2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbmNvbWluZyBjYWxsIGZyb206JywgZnJvbSk7XG4gICAgICAgICAgLy8gU2hvdyBpbmNvbWluZyBjYWxsIG5vdGlmaWNhdGlvbiBpbnN0ZWFkIG9mIGF1dG8tYWNjZXB0aW5nXG4gICAgICAgICAgc2V0SW5jb21pbmdDYWxsKHsgZnJvbSwgdG8sIG9mZmVyIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBoYW5kbGVBbnN3ZXIgPSBhc3luYyAoeyBmcm9tLCB0bywgYW5zd2VyIH06IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyBhbnN3ZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIC8vIFZhbGlkIHN0YXRlcyBmb3Igc2V0dGluZyByZW1vdGUgYW5zd2VyOiBoYXZlLWxvY2FsLW9mZmVyIG9yIHN0YWJsZSAoaW4gc29tZSByb2xsYmFjayBzY2VuYXJpb3MpXG4gICAgICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSBcImhhdmUtbG9jYWwtb2ZmZXJcIiB8fCBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gXCJzdGFibGVcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZGVzY3JpcHRpb24gc2V0IHN1Y2Nlc3NmdWxseSwgc3RhdGU6JywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNldCByZW1vdGUgZGVzY3JpcHRpb246JywgZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uOiBDb25uZWN0aW9uIG5vdCBpbiB2YWxpZCBzdGF0ZSwgY3VycmVudCBzdGF0ZTonLCBwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGVzXG4gICAgICAgICAgd2hpbGUgKGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCdWZmZXJlZCBJQ0UgY2FuZGlkYXRlIGFkZGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0U2hvd0VuZENhbGxCdXR0b24odHJ1ZSk7XG4gICAgICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgICAgIHNldElzQ2FsbEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICBzZXRDYWxsVGltZXIoMCk7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgICAgIC8vIFNob3cgY2FsbCBhY2NlcHRlZCBub3RpZmljYXRpb24gdG8gY2FsbGVyXG4gICAgICAgICAgaWYgKGZyb20gPT09IHVzZXJuYW1lKSB7XG4gICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYCR7dG99IGFjY2VwdGVkIHlvdXIgY2FsbGAsXG4gICAgICAgICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgYW5zd2VyIGxpc3RlbmVyIGFuZCBhZGQgbmV3IG9uZSB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub2ZmKCdhbnN3ZXInKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Fuc3dlcicsIGhhbmRsZUFuc3dlcik7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgSUNFIGNhbmRpZGF0ZTonLCBjYW5kaWRhdGUpO1xuICAgICAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHBlZXIgY29ubmVjdGlvbiBpcyByZWFkeSBmb3IgSUNFIGNhbmRpZGF0ZXNcbiAgICAgICAgICBpZiAocGMucmVtb3RlRGVzY3JpcHRpb24gJiYgcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJQ0UgY2FuZGlkYXRlIGFkZGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIElDRSBjYW5kaWRhdGU6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVtb3RlIGRlc2NyaXB0aW9uIG5vdCBzZXQgeWV0LCBidWZmZXJpbmcgSUNFIGNhbmRpZGF0ZScpO1xuICAgICAgICAgICAgLy8gQnVmZmVyIHRoZSBjYW5kaWRhdGUgdG8gYWRkIGxhdGVyXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2VuZC1jYWxsJywgKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY2FsbC1lbmRlZCcsICgpID0+IHtcbiAgICAgICAgICBzZXRTaG93UmVtb3RlVmlkZW8oZmFsc2UpO1xuICAgICAgICAgIGVuZENhbGwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2NhbGwtcmVqZWN0ZWQnLCAoeyBmcm9tLCB0byB9OiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgLy8gU2hvdyBjYWxsIHJlamVjdGVkIG5vdGlmaWNhdGlvbiB0byBjYWxsZXJcbiAgICAgICAgICBpZiAodG8gPT09IHVzZXJuYW1lKSB7XG4gICAgICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYCR7ZnJvbX0gcmVqZWN0ZWQgeW91ciBjYWxsYCxcbiAgICAgICAgICAgICAgdHlwZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VzZXJuYW1lLXRha2VuJywgKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIHRha2VuOicsIG1lc3NhZ2UpO1xuICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6ICdlbmQnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldENhbGxOb3RpZmljYXRpb24obnVsbCk7XG4gICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvY2tldC5pbyBzZXJ2ZXI6JywgZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgUGVlckNvbm5lY3Rpb246IFBlZXJDb25uZWN0aW9uTWFuYWdlciA9ICgoKSA9PiB7XG4gICAgbGV0IHBlZXJDb25uZWN0aW9uOiBSVENQZWVyQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3QgY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGljZVNlcnZlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1cmxzOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMidcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgICBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWcpO1xuXG4gICAgICAvLyBDbGVhciBJQ0UgY2FuZGlkYXRlcyBidWZmZXIgd2hlbiBjcmVhdGluZyBuZXcgY29ubmVjdGlvblxuICAgICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50ID0gW107XG5cbiAgICAgIGlmIChsb2NhbFN0cmVhbVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgc2VuZGVyIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHRyYWNrXG4gICAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbiEuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbiEuYWRkVHJhY2sodHJhY2ssIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChyZW1vdGVWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICByZW1vdGVWaWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gZXZlbnQuc3RyZWFtc1swXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdpY2VjYW5kaWRhdGUnLCBldmVudC5jYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwZWVyQ29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkOicsIHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHBlZXJDb25uZWN0aW9uPy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0SW5zdGFuY2U6ICgpID0+IHtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIGZvciBlYWNoIGNhbGxcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBwZWVyQ29ubmVjdGlvbiA9IGNyZWF0ZVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbjtcbiAgICAgIH0sXG4gICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgIHBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBJQ0UgY2FuZGlkYXRlcyBidWZmZXIgb24gcmVzZXRcbiAgICAgICAgaWNlQ2FuZGlkYXRlc0J1ZmZlci5jdXJyZW50ID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBjb25zdCBoYW5kbGVVc2VybmFtZUNyZWF0ZWQgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyB1c2VyOicsIG5ld1VzZXJuYW1lKTtcbiAgICBzZXRVc2VybmFtZShuZXdVc2VybmFtZSk7XG4gICAgXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIEFkZCBjdXJyZW50IHVzZXIgdG8gbG9jYWwgbGlzdCBpbW1lZGlhdGVseSBmb3IgYmV0dGVyIFVYXG4gICAgc2V0VXNlcnMocHJldiA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkVXNlcnMgPSB7IC4uLnByZXYsIFtuZXdVc2VybmFtZV06IG5ld1VzZXJuYW1lIH07XG4gICAgICBjb25zb2xlLmxvZygnTG9jYWwgdXNlcnMgdXBkYXRlZDonLCB1cGRhdGVkVXNlcnMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWRVc2VycztcbiAgICB9KTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB0byBzeW5jIHdpdGggb3RoZXIgZGV2aWNlc1xuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ0VtaXR0ZWQgam9pbi11c2VyIGV2ZW50IGZvcjonLCBuZXdVc2VybmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0YXJ0TXlWaWRlbyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSwgdmlkZW86IHRydWUgfSk7XG4gICAgICBjb25zb2xlLmxvZyh7IHN0cmVhbSB9KTtcbiAgICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBtZWRpYSBkZXZpY2VzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZW5kQ2FsbCA9ICgpID0+IHtcbiAgICBQZWVyQ29ubmVjdGlvbi5yZXNldCgpO1xuICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKGZhbHNlKTtcbiAgICBzZXRTaG93UmVtb3RlVmlkZW8oZmFsc2UpO1xuICAgIHNldFJlbW90ZURlc2NyaXB0aW9uU2V0KGZhbHNlKTtcbiAgICBzZXRTdGFydENhbWVyYShmYWxzZSk7XG4gICAgc2V0SXNDYWxsQWN0aXZlKGZhbHNlKTtcbiAgICBzZXRDYWxsVGltZXIoMCk7XG4gICAgc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICBpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVBY2NlcHRDYWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaW5jb21pbmdDYWxsKSByZXR1cm47XG5cbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBhY2NlcHRpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG5cbiAgICAvLyBXYWl0IGEgYml0IGZvciBjYW1lcmEgdG8gc3RhcnRcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBjID0gUGVlckNvbm5lY3Rpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgYXdhaXQgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oaW5jb21pbmdDYWxsLm9mZmVyKTtcbiAgICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb25TZXQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3Qgc2V0IHJlbW90ZSBkZXNjcmlwdGlvbjogQ29ubmVjdGlvbiBub3QgaW4gc3RhYmxlIHN0YXRlLCBjdXJyZW50IHN0YXRlOicsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnVmZmVyZWQgSUNFIGNhbmRpZGF0ZXNcbiAgICAgIHdoaWxlIChpY2VDYW5kaWRhdGVzQnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZXNCdWZmZXIuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1ZmZlcmVkIElDRSBjYW5kaWRhdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5IGluIGhhbmRsZUFjY2VwdENhbGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGJ1ZmZlcmVkIElDRSBjYW5kaWRhdGUgaW4gaGFuZGxlQWNjZXB0Q2FsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBhd2FpdCBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cbiAgICAgIC8vIEFkZCBsb2NhbCBzdHJlYW0gdG8gcGVlciBjb25uZWN0aW9uXG4gICAgICBpZiAobG9jYWxTdHJlYW1SZWYuY3VycmVudCkge1xuICAgICAgICBsb2NhbFN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbmRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIGlmICghcGMuZ2V0U2VuZGVycygpLnNvbWUoc2VuZGVyID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgbG9jYWxTdHJlYW1SZWYuY3VycmVudCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdhbnN3ZXInLCB7XG4gICAgICAgIGZyb206IGluY29taW5nQ2FsbC50byxcbiAgICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tLFxuICAgICAgICBhbnN3ZXI6IHBjLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgIH0pO1xuXG4gICAgICBzZXRDYWxsZXIoW2luY29taW5nQ2FsbC5mcm9tLCBpbmNvbWluZ0NhbGwudG9dKTtcbiAgICAgIHNldEluY29taW5nQ2FsbChudWxsKTtcbiAgICAgIHNldFNob3dFbmRDYWxsQnV0dG9uKHRydWUpO1xuICAgICAgc2V0U2hvd1JlbW90ZVZpZGVvKHRydWUpO1xuICAgICAgc2V0SXNDYWxsQWN0aXZlKHRydWUpO1xuICAgICAgc2V0Q2FsbFRpbWVyKDApO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcblxuICAgICAgLy8gU2hvdyBjYWxsIHN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYWxsIHN0YXJ0ZWQgd2l0aCAke2luY29taW5nQ2FsbC5mcm9tfWAsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIG5vdGlmaWNhdGlvbiBhZnRlciAzIHNlY29uZHNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVqZWN0Q2FsbCA9ICgpID0+IHtcbiAgICBpZiAoIWluY29taW5nQ2FsbCkgcmV0dXJuO1xuXG4gICAgLy8gTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCBjYWxsIHdhcyByZWplY3RlZFxuICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdjYWxsLXJlamVjdGVkJywge1xuICAgICAgZnJvbTogaW5jb21pbmdDYWxsLnRvLFxuICAgICAgdG86IGluY29taW5nQ2FsbC5mcm9tXG4gICAgfSk7XG5cbiAgICBzZXRJbmNvbWluZ0NhbGwobnVsbCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRW5kQ2FsbCA9ICgpID0+IHtcbiAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnY2FsbC1lbmRlZCcsIGNhbGxlcik7XG5cbiAgICAvLyBTaG93IGNhbGwgZW5kIG5vdGlmaWNhdGlvblxuICAgIGNvbnN0IG90aGVyVXNlciA9IGNhbGxlci5maW5kKHVzZXIgPT4gdXNlciAhPT0gdXNlcm5hbWUpO1xuICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgbWVzc2FnZTogYENhbGwgZW5kZWQgd2l0aCAke290aGVyVXNlcn1gLFxuICAgICAgdHlwZTogJ2VuZCdcbiAgICB9KTtcblxuICAgIC8vIEhpZGUgbm90aWZpY2F0aW9uIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVSZW1vdGVWaWRlb1JlZiA9IChyZWY6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVtb3RlVmlkZW9FbGVtZW50KHJlZik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU3RyZWFtUmVhZHkgPSAoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgIGxvY2FsU3RyZWFtUmVmLmN1cnJlbnQgPSBzdHJlYW07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVXNlcm5hbWVDaGFuZ2UgPSAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VicnRjLXVzZXJuYW1lJywgbmV3VXNlcm5hbWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICBcbiAgICAvLyBFbWl0IHRvIHNlcnZlciB3aXRoIG5ldyB1c2VybmFtZVxuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnam9pbi11c2VyJywgbmV3VXNlcm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIGNoYW5nZWQgdG86JywgbmV3VXNlcm5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmb3JtYXRUaW1lciA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBzZWNvbmRzICUgNjA7XG4gICAgcmV0dXJuIGAke21pbnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRDYWxsID0gYXN5bmMgKHVzZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKHsgdXNlciB9KTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgaWYgKCF1c2VybmFtZSB8fCB1c2VybmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICBzZXRDYWxsTm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBjcmVhdGUgYSB1c2VybmFtZSBmaXJzdCcsXG4gICAgICAgIHR5cGU6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDYWxsTm90aWZpY2F0aW9uKG51bGwpLCAzMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0YXJnZXQgdXNlciBleGlzdHNcbiAgICBpZiAoIXVzZXJzW3VzZXJdKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBjYWxsOiBUYXJnZXQgdXNlciBub3QgZm91bmQnKTtcbiAgICAgIHNldENhbGxOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiBgVXNlciAke3VzZXJ9IGlzIG5vdCBhdmFpbGFibGVgLFxuICAgICAgICB0eXBlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Q2FsbE5vdGlmaWNhdGlvbihudWxsKSwgMzAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXRlIHRvIGNvbm5lY3RpbmdcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICBcbiAgICAvLyBTdGFydCBjYW1lcmEgd2hlbiBtYWtpbmcgYSBjYWxsXG4gICAgc2V0U3RhcnRDYW1lcmEodHJ1ZSk7XG4gICAgXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FtZXJhIHRvIHN0YXJ0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYyA9IFBlZXJDb25uZWN0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICBjb25zb2xlLmxvZyh7IG9mZmVyIH0pO1xuICAgICAgYXdhaXQgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnb2ZmZXInLCB7IGZyb206IHVzZXJuYW1lLCB0bzogdXNlciwgb2ZmZXI6IHBjLmxvY2FsRGVzY3JpcHRpb24gfSk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRWRpdFVzZXIgPSAoKSA9PiB7XG4gICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGVkaXQgbW9kYWwgaW4gVmlkZW9DYWxsIGNvbXBvbmVudFxuICAgIC8vIFdlJ2xsIHVzZSBhIHN0YXRlIHRvIGNvbW11bmljYXRlIGJldHdlZW4gY29tcG9uZW50c1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdvcGVuRWRpdE1vZGFsJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyVXNlckRhdGEgPSAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dlYnJ0Yy11c2VybmFtZScpO1xuICAgIHNldFVzZXJuYW1lKCcnKTtcbiAgICBzZXRVc2Vycyh7fSk7XG4gICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDbGVhciBhbGwgdXNlcnMgZnJvbSBzZXJ2ZXJcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2NsZWFyLWFsbC11c2VycycpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gUmVjb25uZWN0IGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJoLXNjcmVlbiBmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93XCI+XG4gICAgICA8VXNlckxpc3RcbiAgICAgICAgdXNlcnM9e3VzZXJzfVxuICAgICAgICBjdXJyZW50VXNlcj17dXNlcm5hbWV9XG4gICAgICAgIG9uU3RhcnRDYWxsPXtzdGFydENhbGx9XG4gICAgICAgIG9uRWRpdFVzZXI9e2hhbmRsZUVkaXRVc2VyfVxuICAgICAgLz5cbiAgICAgIDxWaWRlb0NhbGxcbiAgICAgICAgdXNlcm5hbWU9e3VzZXJuYW1lfVxuICAgICAgICBvblVzZXJuYW1lQ3JlYXRlZD17aGFuZGxlVXNlcm5hbWVDcmVhdGVkfVxuICAgICAgICBvbkVuZENhbGw9e2hhbmRsZUVuZENhbGx9XG4gICAgICAgIHNob3dFbmRDYWxsQnV0dG9uPXtzaG93RW5kQ2FsbEJ1dHRvbn1cbiAgICAgICAgaW5jb21pbmdDYWxsPXtpbmNvbWluZ0NhbGx9XG4gICAgICAgIG9uQWNjZXB0Q2FsbD17aGFuZGxlQWNjZXB0Q2FsbH1cbiAgICAgICAgb25SZWplY3RDYWxsPXtoYW5kbGVSZWplY3RDYWxsfVxuICAgICAgICBjYWxsTm90aWZpY2F0aW9uPXtjYWxsTm90aWZpY2F0aW9ufVxuICAgICAgICBvblJlbW90ZVZpZGVvUmVmPXtoYW5kbGVSZW1vdGVWaWRlb1JlZn1cbiAgICAgICAgc2hvd1JlbW90ZVZpZGVvPXtzaG93UmVtb3RlVmlkZW99XG4gICAgICAgIHN0YXJ0Q2FtZXJhPXtzdGFydENhbWVyYX1cbiAgICAgICAgb25TdHJlYW1SZWFkeT17aGFuZGxlU3RyZWFtUmVhZHl9XG4gICAgICAgIGNhbGxUaW1lcj17Y2FsbFRpbWVyfVxuICAgICAgICBpc0NhbGxBY3RpdmU9e2lzQ2FsbEFjdGl2ZX1cbiAgICAgICAgb25Vc2VybmFtZUNoYW5nZT17aGFuZGxlVXNlcm5hbWVDaGFuZ2V9XG4gICAgICAgIG9uQ2xlYXJEYXRhPXtjbGVhclVzZXJEYXRhfVxuICAgICAgICBjb25uZWN0aW9uU3RhdGU9e2Nvbm5lY3Rpb25TdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9tYWluPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaW8iLCJVc2VyTGlzdCIsIlZpZGVvQ2FsbCIsIkhvbWUiLCJ1c2VybmFtZSIsInNldFVzZXJuYW1lIiwidXNlcnMiLCJzZXRVc2VycyIsInNob3dFbmRDYWxsQnV0dG9uIiwic2V0U2hvd0VuZENhbGxCdXR0b24iLCJjYWxsZXIiLCJzZXRDYWxsZXIiLCJpbmNvbWluZ0NhbGwiLCJzZXRJbmNvbWluZ0NhbGwiLCJjYWxsTm90aWZpY2F0aW9uIiwic2V0Q2FsbE5vdGlmaWNhdGlvbiIsInNob3dSZW1vdGVWaWRlbyIsInNldFNob3dSZW1vdGVWaWRlbyIsInJlbW90ZURlc2NyaXB0aW9uU2V0Iiwic2V0UmVtb3RlRGVzY3JpcHRpb25TZXQiLCJzdGFydENhbWVyYSIsInNldFN0YXJ0Q2FtZXJhIiwiY2FsbFRpbWVyIiwic2V0Q2FsbFRpbWVyIiwiaXNDYWxsQWN0aXZlIiwic2V0SXNDYWxsQWN0aXZlIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwiaWNlQ2FuZGlkYXRlc0J1ZmZlciIsInNvY2tldFJlZiIsImxvY2FsU3RyZWFtUmVmIiwicGVlckNvbm5lY3Rpb25SZWYiLCJyZW1vdGVWaWRlb0VsZW1lbnQiLCJzZXRSZW1vdGVWaWRlb0VsZW1lbnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHJldiIsImNsZWFySW50ZXJ2YWwiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiZmV0Y2giLCJ0aGVuIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJwYXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0Iiwib24iLCJpZCIsImVycm9yIiwiYWxsVXNlcnMiLCJmcm9tIiwidG8iLCJvZmZlciIsImhhbmRsZUFuc3dlciIsImFuc3dlciIsInBjIiwiUGVlckNvbm5lY3Rpb24iLCJnZXRJbnN0YW5jZSIsInNpZ25hbGluZ1N0YXRlIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJsZW5ndGgiLCJjYW5kaWRhdGUiLCJzaGlmdCIsImFkZEljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsIm1lc3NhZ2UiLCJ0eXBlIiwic2V0VGltZW91dCIsIm9mZiIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsImVuZENhbGwiLCJjYXRjaCIsImRpc2Nvbm5lY3QiLCJwZWVyQ29ubmVjdGlvbiIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwiY29uZmlnIiwiaWNlU2VydmVycyIsInVybHMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImdldFNlbmRlcnMiLCJzb21lIiwic2VuZGVyIiwiYWRkVHJhY2siLCJvbnRyYWNrIiwiZXZlbnQiLCJzcmNPYmplY3QiLCJzdHJlYW1zIiwib25pY2VjYW5kaWRhdGUiLCJlbWl0Iiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJjbG9zZSIsInJlc2V0IiwiaGFuZGxlVXNlcm5hbWVDcmVhdGVkIiwibmV3VXNlcm5hbWUiLCJzZXRJdGVtIiwidXBkYXRlZFVzZXJzIiwic3RhcnRNeVZpZGVvIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ2aWRlbyIsImhhbmRsZUFjY2VwdENhbGwiLCJjcmVhdGVBbnN3ZXIiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImhhbmRsZVJlamVjdENhbGwiLCJoYW5kbGVFbmRDYWxsIiwib3RoZXJVc2VyIiwiZmluZCIsInVzZXIiLCJoYW5kbGVSZW1vdGVWaWRlb1JlZiIsInJlZiIsImhhbmRsZVN0cmVhbVJlYWR5IiwiaGFuZGxlVXNlcm5hbWVDaGFuZ2UiLCJmb3JtYXRUaW1lciIsInNlY29uZHMiLCJtaW5zIiwiTWF0aCIsImZsb29yIiwic2VjcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydENhbGwiLCJ0cmltIiwiY3JlYXRlT2ZmZXIiLCJoYW5kbGVFZGl0VXNlciIsIkN1c3RvbUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsImNsZWFyVXNlckRhdGEiLCJsb2NhdGlvbiIsInJlbG9hZCIsIm1haW4iLCJjbGFzc05hbWUiLCJjdXJyZW50VXNlciIsIm9uU3RhcnRDYWxsIiwib25FZGl0VXNlciIsIm9uVXNlcm5hbWVDcmVhdGVkIiwib25FbmRDYWxsIiwib25BY2NlcHRDYWxsIiwib25SZWplY3RDYWxsIiwib25SZW1vdGVWaWRlb1JlZiIsIm9uU3RyZWFtUmVhZHkiLCJvblVzZXJuYW1lQ2hhbmdlIiwib25DbGVhckRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ })

});